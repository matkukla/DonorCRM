---
phase: 01-foundation-data-model
plan: 02
type: execute
wave: 2
depends_on: ["01-01"]
files_modified:
  - apps/journals/serializers.py
  - apps/journals/views.py
  - apps/journals/urls.py
  - apps/journals/signals.py
  - apps/events/models.py
  - config/api_urls.py
autonomous: true

must_haves:
  truths:
    - "User can create a journal with name, goal_amount, and deadline via POST /api/v1/journals/"
    - "User can edit journal fields via PATCH /api/v1/journals/{id}/"
    - "User can archive a journal (soft delete) via DELETE /api/v1/journals/{id}/"
    - "System logs stage events when created (append-only with timestamp)"
    - "User sees only their own journals, admins see all journals"
  artifacts:
    - path: "apps/journals/serializers.py"
      provides: "JournalListSerializer, JournalDetailSerializer, JournalCreateSerializer, JournalStageEventSerializer"
      contains: "class JournalCreateSerializer"
    - path: "apps/journals/views.py"
      provides: "JournalListCreateView, JournalDetailView, JournalStageEventListCreateView"
      contains: "class JournalListCreateView"
    - path: "apps/journals/urls.py"
      provides: "URL patterns for journals API"
      contains: "app_name = 'journals'"
    - path: "apps/journals/signals.py"
      provides: "Signal handlers for journal event creation"
      contains: "@receiver(post_save"
    - path: "config/api_urls.py"
      provides: "journals URL registration"
      contains: "path('journals/', include('apps.journals.urls'))"
  key_links:
    - from: "apps/journals/views.py"
      to: "apps/journals/models.py"
      via: "model imports for querysets"
      pattern: "from apps.journals.models import Journal"
    - from: "apps/journals/views.py"
      to: "apps/core/permissions.py"
      via: "IsOwnerOrAdmin permission class"
      pattern: "IsOwnerOrAdmin"
    - from: "apps/journals/serializers.py"
      to: "apps/journals/models.py"
      via: "ModelSerializer Meta.model"
      pattern: "model = Journal"
    - from: "config/api_urls.py"
      to: "apps/journals/urls.py"
      via: "include() in urlpatterns"
      pattern: "include.*apps.journals.urls"
    - from: "apps/journals/signals.py"
      to: "apps/events/models.py"
      via: "Event.objects.create in signal handler"
      pattern: "Event.objects.create"
---

<objective>
Create the complete Journal CRUD API with serializers, views, URL routing, permission enforcement, event logging signals, and stage event endpoint.

Purpose: Delivers all five Phase 1 success criteria - journal create/edit/archive, stage event logging, and owner+admin visibility. After this plan, the API is fully functional and testable.
Output: Working REST API at /api/v1/journals/ with CRUD operations, permission scoping, and event audit trail.
</objective>

<execution_context>
@/home/matkukla/.claude/get-shit-done/workflows/execute-plan.md
@/home/matkukla/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/01-foundation-data-model/01-RESEARCH.md
@apps/journals/models.py
@apps/core/permissions.py
@apps/pledges/views.py
@apps/pledges/serializers.py
@apps/pledges/signals.py
@apps/pledges/urls.py
@apps/contacts/views.py
@apps/contacts/serializers.py
@apps/events/models.py
@config/api_urls.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create serializers, views, and URL routing</name>
  <files>
    apps/journals/serializers.py
    apps/journals/views.py
    apps/journals/urls.py
    config/api_urls.py
  </files>
  <action>
1. `apps/journals/serializers.py` - Create four serializers:

**JournalListSerializer** (ModelSerializer):
- Model: Journal
- Fields: id, name, goal_amount, deadline, is_archived, created_at, updated_at
- Read-only: id, created_at, updated_at, is_archived

**JournalDetailSerializer** (ModelSerializer):
- Model: Journal
- Fields: id, name, goal_amount, deadline, is_archived, archived_at, owner, created_at, updated_at
- Read-only: id, owner, is_archived, archived_at, created_at, updated_at
- owner field: Use PrimaryKeyRelatedField(read_only=True) or SerializerMethodField to show owner UUID

**JournalCreateSerializer** (ModelSerializer):
- Model: Journal
- Fields: id, name, goal_amount, deadline
- Read-only: id
- Override create() method: auto-assign owner from request.user (follow ContactCreateSerializer pattern)
- Validation: name is required, goal_amount must be > 0 (validator on model handles this)

**JournalStageEventSerializer** (ModelSerializer):
- Model: JournalStageEvent
- Fields: id, journal_contact, stage, event_type, notes, metadata, triggered_by, created_at
- Read-only: id, triggered_by, created_at
- Override create(): auto-assign triggered_by from request.user

2. `apps/journals/views.py` - Create three views:

**JournalListCreateView** (generics.ListCreateAPIView):
- permission_classes: [IsAuthenticated]
- filter_backends: [DjangoFilterBackend, SearchFilter, OrderingFilter]
- search_fields: ['name']
- ordering_fields: ['name', 'created_at', 'deadline', 'goal_amount']
- ordering: ['-created_at']
- filterset_fields: ['is_archived']
- get_queryset(): Admin sees all, staff sees owner=user. Exclude archived by default unless is_archived param present. Use select_related('owner').
- get_serializer_class(): POST returns JournalCreateSerializer, GET returns JournalListSerializer

**JournalDetailView** (generics.RetrieveUpdateDestroyAPIView):
- permission_classes: [IsAuthenticated, IsOwnerOrAdmin]
- get_queryset(): Same ownership scoping as list view (admin=all, staff=own). Use select_related('owner').
- get_serializer_class(): Return JournalDetailSerializer
- Override destroy(): Instead of deleting, call instance.archive() and return 204. This implements soft-delete via DELETE verb.

**JournalStageEventListCreateView** (generics.ListCreateAPIView):
- permission_classes: [IsAuthenticated]
- get_queryset(): Filter JournalStageEvent by journal_contact__journal__owner=user (staff) or all (admin). Accept query param journal_contact_id to filter. Use select_related('journal_contact', 'journal_contact__journal', 'journal_contact__contact', 'triggered_by'). Order by '-created_at'.
- get_serializer_class(): Return JournalStageEventSerializer
- Note: This endpoint is at /api/v1/journals/stage-events/ for now (will be nested under journal-contacts in Phase 2)

3. `apps/journals/urls.py` - URL patterns:
```python
app_name = 'journals'
urlpatterns = [
    path('', JournalListCreateView.as_view(), name='journal-list'),
    path('<uuid:pk>/', JournalDetailView.as_view(), name='journal-detail'),
    path('stage-events/', JournalStageEventListCreateView.as_view(), name='stage-event-list'),
]
```

4. `config/api_urls.py` - Add after the 'imports/' line:
```python
# Journals
path('journals/', include('apps.journals.urls')),
```

Follow these conventions:
- Use absolute imports (from apps.journals.models import ...)
- Add @extend_schema decorators with brief descriptions (from drf_spectacular.utils import extend_schema)
- Use IsOwnerOrAdmin from apps.core.permissions (it already exists and checks obj.owner)
- Import filter backends: from django_filters.rest_framework import DjangoFilterBackend and from rest_framework import filters
  </action>
  <verify>
Run the dev server briefly: `python manage.py runserver 0.0.0.0:8000 &` then:
- `curl -s http://localhost:8000/api/v1/journals/ -H "Content-Type: application/json" | python -m json.tool` should return 401 (unauthenticated)
- `python manage.py shell -c "from apps.journals.views import JournalListCreateView, JournalDetailView; print('Views imported OK')"`
- `python manage.py show_urls 2>/dev/null | grep journals` or check URL resolution works
Kill the server after verification.
  </verify>
  <done>
- JournalListCreateView handles GET (list) and POST (create) at /api/v1/journals/
- JournalDetailView handles GET/PATCH/DELETE at /api/v1/journals/{uuid}/
- DELETE calls archive() for soft-delete behavior
- Ownership scoping works: staff sees own, admin sees all
- Stage events can be created via POST /api/v1/journals/stage-events/
  </done>
</task>

<task type="auto">
  <name>Task 2: Add event logging signals and new EventType values</name>
  <files>
    apps/journals/signals.py
    apps/events/models.py
  </files>
  <action>
1. `apps/events/models.py` - Add new EventType choices for journals. Add these entries to the EventType TextChoices class, in a new "Journal events" section after the existing "System events" section:
```python
# Journal events
JOURNAL_CREATED = 'journal_created', 'Journal Created'
JOURNAL_ARCHIVED = 'journal_archived', 'Journal Archived'
JOURNAL_STAGE_EVENT = 'journal_stage_event', 'Journal Stage Event'
```

2. `apps/journals/signals.py` - Replace the placeholder with full signal implementations:

**Signal 1: handle_journal_created** (post_save on Journal):
- Only fire when created=True
- Import Event, EventType, EventSeverity inside the handler (avoid circular imports)
- Create Event with:
  - user=instance.owner
  - event_type=EventType.JOURNAL_CREATED
  - title=f'Journal created: {instance.name}'
  - message=f'Goal: ${instance.goal_amount}'
  - severity=EventSeverity.INFO
  - metadata={'journal_id': str(instance.id), 'goal_amount': str(instance.goal_amount)}

**Signal 2: handle_stage_event_created** (post_save on JournalStageEvent):
- Only fire when created=True
- Import Event, EventType, EventSeverity inside the handler
- Get the journal from instance.journal_contact.journal
- Create Event with:
  - user=journal.owner
  - event_type=EventType.JOURNAL_STAGE_EVENT
  - title=f'{instance.get_stage_display()}: {instance.get_event_type_display()}'
  - message=instance.notes[:200] if instance.notes else ''
  - severity=EventSeverity.INFO
  - metadata={'journal_id': str(journal.id), 'stage': instance.stage, 'event_type': instance.event_type, 'journal_contact_id': str(instance.journal_contact_id)}

Both signals should use @receiver decorator and import sender model at top level (Journal and JournalStageEvent are in same app, no circular import risk).

3. Run `python manage.py makemigrations events` to create migration for the new EventType choices (CharField choices don't usually need migrations since they're not enforced at DB level, but run it to be safe - if no migration generated, that's fine).

Follow the pitfall avoidance:
- Import Event model INSIDE handler functions to avoid circular imports with events app
- Wrap Event creation in try/except to avoid crashing save operations (log warning on failure)
  </action>
  <verify>
Test signal fires by creating a journal in shell:
```python
python manage.py shell -c "
from django.contrib.auth import get_user_model
from apps.journals.models import Journal
from apps.events.models import Event, EventType
from decimal import Decimal

User = get_user_model()
user = User.objects.first()
if user:
    j = Journal.objects.create(owner=user, name='Test Signal Journal', goal_amount=Decimal('5000.00'))
    events = Event.objects.filter(event_type=EventType.JOURNAL_CREATED)
    print(f'Journal created: {j.id}')
    print(f'Events found: {events.count()}')
    # Cleanup
    events.delete()
    j.delete()
    print('Cleanup done')
else:
    print('No user found - create one first to test signals')
"
```
  </verify>
  <done>
- Journal creation fires signal that creates JOURNAL_CREATED event in events table
- Stage event creation fires signal that creates JOURNAL_STAGE_EVENT event
- EventType enum has three new journal-related values
- Signals are registered via apps.py ready() method
- Signal handlers are wrapped in try/except for safety
  </done>
</task>

</tasks>

<verification>
1. POST /api/v1/journals/ with valid auth creates a journal and returns 201
2. GET /api/v1/journals/ returns only the authenticated user's journals (not other users')
3. PATCH /api/v1/journals/{id}/ updates journal fields
4. DELETE /api/v1/journals/{id}/ sets is_archived=True (does NOT hard delete)
5. POST /api/v1/journals/stage-events/ creates a stage event with timestamp
6. Creating a journal produces a JOURNAL_CREATED event in the events table
7. Creating a stage event produces a JOURNAL_STAGE_EVENT event in the events table
8. Admin user can see all journals via GET /api/v1/journals/
9. Staff user only sees their own journals
</verification>

<success_criteria>
- Full CRUD API works at /api/v1/journals/ and /api/v1/journals/{uuid}/
- Soft delete via DELETE verb (archive pattern, not hard delete)
- Owner-scoped visibility (staff=own, admin=all)
- Stage events are append-only (no update/delete endpoint)
- Signals create audit events on journal creation and stage event creation
- No N+1 queries (select_related used in all querysets)
- All five Phase 1 success criteria from ROADMAP.md are satisfied
</success_criteria>

<output>
After completion, create `.planning/phases/01-foundation-data-model/01-02-SUMMARY.md`
</output>
