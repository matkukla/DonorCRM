---
phase: 02-contact-membership-search
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - apps/journals/serializers.py
  - apps/journals/views.py
  - apps/journals/urls.py
autonomous: true

must_haves:
  truths:
    - "POST /api/v1/journals/journal-members/ with valid journal+contact IDs returns 201"
    - "POST with duplicate journal+contact pair returns 400 (not 500)"
    - "POST with contact owned by different user returns 400 validation error"
    - "DELETE /api/v1/journals/journal-members/{id}/ removes membership and returns 204"
    - "GET /api/v1/journals/journal-members/?journal_id=X returns only contacts in that journal"
    - "User cannot see or modify memberships for journals they do not own"
  artifacts:
    - path: "apps/journals/serializers.py"
      provides: "JournalContactSerializer with ownership validation"
      contains: "class JournalContactSerializer"
    - path: "apps/journals/views.py"
      provides: "JournalContactListCreateView and JournalContactDestroyView"
      contains: "class JournalContactListCreateView"
    - path: "apps/journals/urls.py"
      provides: "journal-members/ URL patterns"
      contains: "journal-members/"
  key_links:
    - from: "apps/journals/views.py"
      to: "apps/journals/serializers.py"
      via: "serializer_class = JournalContactSerializer"
      pattern: "serializer_class.*JournalContactSerializer"
    - from: "apps/journals/views.py"
      to: "apps/journals/models.py"
      via: "JournalContact.objects.select_related"
      pattern: "JournalContact\\.objects\\.select_related"
    - from: "apps/journals/urls.py"
      to: "apps/journals/views.py"
      via: "URL routing to views"
      pattern: "JournalContactListCreateView\\.as_view"
---

<objective>
Create the JournalContact membership API: serializer with ownership validation, views with atomic transactions and search/filter, and URL routing.

Purpose: Enables adding/removing contacts to journals with proper permission checks, duplicate handling, and query optimization. This is the core CRUD for Phase 2.
Output: Working POST/DELETE/GET endpoints at /api/v1/journals/journal-members/
</objective>

<execution_context>
@/home/matkukla/.claude/get-shit-done/workflows/execute-plan.md
@/home/matkukla/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@apps/journals/models.py
@apps/journals/views.py
@apps/journals/serializers.py
@apps/journals/urls.py
@apps/core/permissions.py
@apps/contacts/models.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: JournalContact serializer and views</name>
  <files>apps/journals/serializers.py, apps/journals/views.py</files>
  <action>
1. In apps/journals/serializers.py, add JournalContactSerializer:
   - ModelSerializer for JournalContact model
   - Fields: id, journal, contact, contact_name (read-only, source='contact.full_name'), contact_email (read-only, source='contact.email'), contact_status (read-only, source='contact.status'), created_at
   - read_only_fields: id, created_at
   - validate() method that checks:
     a. request.user owns the journal (journal.owner == user) OR user.role == 'admin'
     b. request.user owns the contact (contact.owner == user) OR user.role == 'admin'
     c. Raise serializers.ValidationError with field-specific messages if either fails

2. In apps/journals/views.py, add JournalContactListCreateView (generics.ListCreateAPIView):
   - permission_classes = [permissions.IsAuthenticated]
   - serializer_class = JournalContactSerializer
   - filter_backends = [DjangoFilterBackend, filters.SearchFilter, filters.OrderingFilter]
   - search_fields = ['contact__first_name', 'contact__last_name', 'contact__email']
   - filterset_fields = ['contact__status']
   - ordering_fields = ['created_at', 'contact__first_name', 'contact__last_name']
   - ordering = ['-created_at']
   - get_queryset():
     * Base: JournalContact.objects.select_related('journal', 'contact')
     * If user.role != 'admin': filter(journal__owner=user)
     * Always filter(journal__is_archived=False) to exclude archived journals
     * If journal_id query param provided: filter(journal_id=journal_id)
   - create() override:
     * Wrap in try/with transaction.atomic()
     * Call super().create() inside atomic block
     * Catch IntegrityError: if 'unique' in str(e).lower(), return Response({'detail': 'Contact already in this journal'}, status=400)
     * Re-raise non-unique IntegrityErrors

3. In apps/journals/views.py, add JournalContactDestroyView (generics.DestroyAPIView):
   - permission_classes = [permissions.IsAuthenticated]
   - serializer_class = JournalContactSerializer
   - get_queryset():
     * Base: JournalContact.objects.select_related('journal', 'contact')
     * If user.role != 'admin': filter(journal__owner=user)
   - perform_destroy() with @transaction.atomic decorator

4. Add necessary imports at top of views.py:
   - from django.db import transaction, IntegrityError
   - Add JournalContact to the model imports
   - Add JournalContactSerializer to the serializer imports

5. Add necessary imports at top of serializers.py:
   - Add JournalContact to the model imports

Do NOT use IsOwnerOrAdmin permission on these views (JournalContact has no direct 'owner' field - ownership is checked via journal.owner in the queryset filter and serializer validation).
  </action>
  <verify>
Run: python -c "import django; django.setup(); from apps.journals.serializers import JournalContactSerializer; from apps.journals.views import JournalContactListCreateView, JournalContactDestroyView; print('OK')" from project root with DJANGO_SETTINGS_MODULE=config.settings set.
  </verify>
  <done>JournalContactSerializer exists with ownership validation. JournalContactListCreateView handles list/create with search/filter/atomic transactions. JournalContactDestroyView handles delete with atomic transaction. All imports resolve.</done>
</task>

<task type="auto">
  <name>Task 2: URL routing and endpoint verification</name>
  <files>apps/journals/urls.py</files>
  <action>
1. In apps/journals/urls.py:
   - Add imports for JournalContactListCreateView, JournalContactDestroyView
   - Add two URL patterns:
     * path('journal-members/', JournalContactListCreateView.as_view(), name='journal-member-list')
     * path('journal-members/<uuid:pk>/', JournalContactDestroyView.as_view(), name='journal-member-detail')

2. Verify the full URL will be /api/v1/journals/journal-members/ by checking the root URL config includes journals app at 'journals/'.
  </action>
  <verify>
Run: python -c "import django; django.setup(); from django.urls import reverse; print(reverse('journals:journal-member-list')); print(reverse('journals:journal-member-detail', kwargs={'pk': '00000000-0000-0000-0000-000000000001'}))" with DJANGO_SETTINGS_MODULE=config.settings.
  </verify>
  <done>URL patterns resolve correctly. journal-member-list maps to journal-members/ and journal-member-detail maps to journal-members/{uuid}/.</done>
</task>

</tasks>

<verification>
1. Import check passes for all new classes
2. URL reverse works for both new endpoints
3. No migration needed (no model changes - JournalContact already exists)
4. python manage.py check passes with no errors
</verification>

<success_criteria>
- JournalContactSerializer validates ownership of both journal and contact
- JournalContactListCreateView supports GET (list with search/filter) and POST (create with atomic transaction + IntegrityError handling)
- JournalContactDestroyView supports DELETE with atomic transaction
- URLs route to correct views
- Queryset scoped by owner (non-admin sees only own journals' memberships)
- Archived journals excluded from list results
- search query param searches contact first_name, last_name, email
- contact__status filter param filters by contact status
</success_criteria>

<output>
After completion, create `.planning/phases/02-contact-membership-search/02-01-SUMMARY.md`
</output>
