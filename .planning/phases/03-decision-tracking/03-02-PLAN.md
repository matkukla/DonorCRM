---
phase: 03-decision-tracking
plan: 02
type: execute
wave: 2
depends_on: ["03-01"]
files_modified:
  - apps/journals/serializers.py
  - apps/journals/views.py
  - apps/journals/urls.py
autonomous: true

must_haves:
  truths:
    - "User can create a decision via POST with amount, cadence, and status"
    - "User can update a decision via PATCH/PUT and system appends old state to history before updating"
    - "User can retrieve paginated decision history (default 25 records per page)"
    - "Duplicate decision for same journal_contact returns 400 not 500"
    - "Only journal owner (or admin) can create/view/update decisions"
  artifacts:
    - path: "apps/journals/serializers.py"
      provides: "DecisionSerializer, DecisionHistorySerializer"
      contains: "class DecisionSerializer"
    - path: "apps/journals/views.py"
      provides: "DecisionListCreateView, DecisionDetailView, DecisionHistoryListView"
      contains: "class DecisionListCreateView"
    - path: "apps/journals/urls.py"
      provides: "URL routing for decisions/ and decision-history/ endpoints"
      contains: "decisions/"
  key_links:
    - from: "apps/journals/serializers.py (DecisionSerializer.update)"
      to: "apps/journals/models.py (DecisionHistory)"
      via: "transaction.atomic() wrapping history create + decision update"
      pattern: "transaction.atomic"
    - from: "apps/journals/views.py (DecisionHistoryListView)"
      to: "apps/journals/serializers.py (DecisionHistorySerializer)"
      via: "pagination_class with page_size=25"
      pattern: "DecisionHistoryPagination"
    - from: "apps/journals/urls.py"
      to: "apps/journals/views.py"
      via: "path() routing for decision endpoints"
      pattern: "path.*decisions"
---

<objective>
Create serializers, views, and URL routing for Decision CRUD and DecisionHistory listing.

Purpose: Expose the decision tracking functionality via REST API, with atomic history tracking on updates and paginated history retrieval.
Output: Working API endpoints for creating, reading, updating decisions and listing decision history.
</objective>

<execution_context>
@/home/matkukla/.claude/get-shit-done/workflows/execute-plan.md
@/home/matkukla/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-decision-tracking/03-RESEARCH.md
@.planning/phases/03-decision-tracking/03-01-SUMMARY.md
@apps/journals/models.py
@apps/journals/serializers.py
@apps/journals/views.py
@apps/journals/urls.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add DecisionSerializer and DecisionHistorySerializer</name>
  <files>apps/journals/serializers.py</files>
  <action>
Add to apps/journals/serializers.py:

1. Import transaction: `from django.db import transaction`
2. Import Decimal: `from decimal import Decimal`
3. Update model imports to include Decision, DecisionHistory, DecisionCadence

4. DecisionSerializer (ModelSerializer):
   - Fields: id, journal_contact, amount, cadence, status, monthly_equivalent, created_at, updated_at
   - read_only_fields: id, monthly_equivalent, created_at, updated_at
   - monthly_equivalent = serializers.DecimalField(max_digits=10, decimal_places=2, read_only=True)
   - validate_journal_contact(): Check request.user owns the journal_contact's journal (unless admin). Raise ValidationError if not.
   - create(): Wrap in transaction.atomic(). Catch IntegrityError for unique constraint violation, return 400 with 'A decision already exists for this contact in this journal.'
   - update(): Wrap in transaction.atomic(). Before updating:
     a. Build changed_fields dict by comparing validated_data values against instance values
     b. For each field in ['amount', 'cadence', 'status']: if field in validated_data and value differs from instance, store old value in changed dict (convert Decimal to str for JSON serialization)
     c. If changed dict is non-empty, create DecisionHistory(decision=instance, changed_fields=changed, changed_by=request.user)
     d. Then update instance fields and save()
     e. Return instance

5. DecisionHistorySerializer (ModelSerializer):
   - Fields: id, decision, changed_fields, changed_by, created_at
   - read_only_fields: ALL fields (this is read-only)
   - changed_by_email = serializers.EmailField(source='changed_by.email', read_only=True, default=None)

Follow existing serializer patterns in this file (see JournalContactSerializer for ownership validation pattern).
  </action>
  <verify>
Run: `python -c "from apps.journals.serializers import DecisionSerializer, DecisionHistorySerializer; print('OK')"`
Run: `python manage.py check` — no errors.
  </verify>
  <done>DecisionSerializer with atomic history tracking on update and DecisionHistorySerializer exist and are importable</done>
</task>

<task type="auto">
  <name>Task 2: Add Decision views, pagination, and URL routing</name>
  <files>apps/journals/views.py, apps/journals/urls.py</files>
  <action>
**In apps/journals/views.py:**

1. Add imports:
   - `from rest_framework.pagination import PageNumberPagination`
   - Update model imports to include Decision, DecisionHistory
   - Update serializer imports to include DecisionSerializer, DecisionHistorySerializer

2. DecisionHistoryPagination class:
   - page_size = 25
   - page_size_query_param = 'page_size'
   - max_page_size = 100

3. DecisionListCreateView (generics.ListCreateAPIView):
   - permission_classes = [permissions.IsAuthenticated]
   - serializer_class = DecisionSerializer
   - get_queryset():
     - Base: Decision.objects.select_related('journal_contact', 'journal_contact__journal', 'journal_contact__contact')
     - If not admin: filter by journal_contact__journal__owner=user
     - Optional filter: journal_contact_id query param
     - Optional filter: journal_id query param (filter journal_contact__journal_id)
     - Return queryset
   - create(): Wrap super().create() in try/except IntegrityError. If 'unique' in str(e).lower(), return Response({'detail': 'A decision already exists for this contact in this journal.'}, status=400). Wrap in transaction.atomic().

4. DecisionDetailView (generics.RetrieveUpdateAPIView):
   - permission_classes = [permissions.IsAuthenticated]
   - serializer_class = DecisionSerializer
   - get_queryset():
     - Same as ListCreate but for single object
     - If not admin: filter by journal_contact__journal__owner=user
     - select_related('journal_contact', 'journal_contact__journal', 'journal_contact__contact')

5. DecisionHistoryListView (generics.ListAPIView):
   - permission_classes = [permissions.IsAuthenticated]
   - serializer_class = DecisionHistorySerializer
   - pagination_class = DecisionHistoryPagination
   - get_queryset():
     - Base: DecisionHistory.objects.select_related('decision', 'decision__journal_contact', 'decision__journal_contact__journal', 'changed_by')
     - If not admin: filter by decision__journal_contact__journal__owner=user
     - Optional filter: decision_id query param
     - Optional filter: journal_contact_id query param (decision__journal_contact_id)
     - Order by -created_at

**In apps/journals/urls.py:**

Add URL patterns:
- path('decisions/', DecisionListCreateView.as_view(), name='decision-list')
- path('decisions/<uuid:pk>/', DecisionDetailView.as_view(), name='decision-detail')
- path('decision-history/', DecisionHistoryListView.as_view(), name='decision-history-list')

Update imports to include new view classes.

Follow existing view patterns in this file (see JournalContactListCreateView for ownership filtering and IntegrityError handling patterns).
  </action>
  <verify>
Run: `python manage.py check` — no errors.
Run: `python -c "from apps.journals.views import DecisionListCreateView, DecisionDetailView, DecisionHistoryListView; print('OK')"`
Run: `python manage.py show_urls 2>/dev/null | grep decision || python -c "from apps.journals.urls import urlpatterns; print([p.name for p in urlpatterns])"` — must show decision-list, decision-detail, decision-history-list.
  </verify>
  <done>Decision CRUD views and history list view with pagination exist, URL routes configured at decisions/ and decision-history/</done>
</task>

</tasks>

<verification>
1. `python manage.py check` passes
2. All serializers and views importable
3. URL patterns registered: decisions/, decisions/<uuid:pk>/, decision-history/
4. DecisionSerializer.update() uses transaction.atomic()
5. DecisionHistoryListView uses pagination with page_size=25
6. Ownership filtering applied on all views (non-admin sees only own journal data)
</verification>

<success_criteria>
- POST /api/v1/journals/decisions/ creates a decision with amount, cadence, status
- PATCH /api/v1/journals/decisions/{id}/ updates decision and creates history record atomically
- GET /api/v1/journals/decision-history/ returns paginated history (25 per page)
- Duplicate decision creation returns 400 with clear message
- Non-owner cannot access or modify decisions
- All select_related calls prevent N+1 queries
</success_criteria>

<output>
After completion, create `.planning/phases/03-decision-tracking/03-02-SUMMARY.md`
</output>
