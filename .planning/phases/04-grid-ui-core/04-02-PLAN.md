---
phase: 04-grid-ui-core
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - frontend/src/api/journals.ts
  - frontend/src/hooks/useJournals.ts
autonomous: true

must_haves:
  truths:
    - "API client fetches journal data from backend"
    - "React Query hooks provide loading/error states"
    - "Event timeline supports infinite scroll pagination"
  artifacts:
    - path: "frontend/src/api/journals.ts"
      provides: "Journal API client functions"
      exports: ["getJournals", "getJournal", "getJournalMembers", "getStageEvents"]
    - path: "frontend/src/hooks/useJournals.ts"
      provides: "React Query hooks for journals"
      exports: ["useJournals", "useJournal", "useJournalMembers", "useStageEventsInfinite"]
  key_links:
    - from: "frontend/src/hooks/useJournals.ts"
      to: "frontend/src/api/journals.ts"
      via: "import API functions"
      pattern: "from.*@/api/journals"
    - from: "frontend/src/api/journals.ts"
      to: "/api/v1/journals/"
      via: "HTTP requests"
      pattern: "apiClient\\.(get|post)"
---

<objective>
Create journal API client and React Query hooks for grid data fetching.

Purpose: The grid UI needs to fetch journal members with their stage event summaries, and the timeline drawer needs paginated event loading. This layer connects the React frontend to Django REST API.

Output: API client functions in journals.ts, React Query hooks in useJournals.ts including useInfiniteQuery for event timeline.
</objective>

<execution_context>
@/home/matkukla/.claude/get-shit-done/workflows/execute-plan.md
@/home/matkukla/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-grid-ui-core/04-RESEARCH.md

Reference existing patterns:
@frontend/src/api/contacts.ts
@frontend/src/api/client.ts
@frontend/src/hooks/useContacts.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create journal API client</name>
  <files>frontend/src/api/journals.ts</files>
  <action>
Create `frontend/src/api/journals.ts` following contacts.ts pattern:

```typescript
import { apiClient } from "./client"
import type {
  JournalListItem,
  JournalDetail,
  JournalMember,
  StageEvent,
  StageEventsPage,
  PipelineStage,
} from "@/types/journals"

/** Paginated response from DRF */
interface PaginatedResponse<T> {
  count: number
  next: string | null
  previous: string | null
  results: T[]
}

/** Filter params for journal list */
export interface JournalFilters {
  is_archived?: boolean
  search?: string
}

/** Get paginated list of journals */
export async function getJournals(
  filters: JournalFilters = {}
): Promise<PaginatedResponse<JournalListItem>> {
  const params = new URLSearchParams()
  if (filters.is_archived !== undefined) {
    params.append('is_archived', String(filters.is_archived))
  }
  if (filters.search) {
    params.append('search', filters.search)
  }
  const response = await apiClient.get<PaginatedResponse<JournalListItem>>(
    `/journals/?${params.toString()}`
  )
  return response.data
}

/** Get single journal by ID */
export async function getJournal(id: string): Promise<JournalDetail> {
  const response = await apiClient.get<JournalDetail>(`/journals/${id}/`)
  return response.data
}

/** Create a new journal */
export interface JournalCreate {
  name: string
  goal_amount: string
  deadline?: string | null
}

export async function createJournal(data: JournalCreate): Promise<JournalDetail> {
  const response = await apiClient.post<JournalDetail>('/journals/', data)
  return response.data
}

/** Update a journal */
export type JournalUpdate = Partial<JournalCreate>

export async function updateJournal(
  id: string,
  data: JournalUpdate
): Promise<JournalDetail> {
  const response = await apiClient.patch<JournalDetail>(`/journals/${id}/`, data)
  return response.data
}

/** Archive (soft delete) a journal */
export async function archiveJournal(id: string): Promise<void> {
  await apiClient.delete(`/journals/${id}/`)
}

/** Filter params for journal members */
export interface JournalMemberFilters {
  journal: string
  search?: string
  stage?: PipelineStage
}

/** Get journal members with stage event summaries */
export async function getJournalMembers(
  journalId: string,
  filters: Omit<JournalMemberFilters, 'journal'> = {}
): Promise<PaginatedResponse<JournalMember>> {
  const params = new URLSearchParams()
  params.append('journal', journalId)
  if (filters.search) {
    params.append('search', filters.search)
  }
  if (filters.stage) {
    params.append('stage', filters.stage)
  }
  const response = await apiClient.get<PaginatedResponse<JournalMember>>(
    `/journal-members/?${params.toString()}`
  )
  return response.data
}

/** Get stage events for a journal contact - supports pagination */
export interface StageEventsParams {
  journalContactId: string
  stage?: PipelineStage
  page?: number
  pageSize?: number
}

export async function getStageEvents({
  journalContactId,
  stage,
  page = 1,
  pageSize = 5,
}: StageEventsParams): Promise<StageEventsPage> {
  const params = new URLSearchParams()
  params.append('journal_contact', journalContactId)
  if (stage) {
    params.append('stage', stage)
  }
  params.append('page', String(page))
  params.append('page_size', String(pageSize))

  const response = await apiClient.get<StageEventsPage>(
    `/journals/stage-events/?${params.toString()}`
  )
  return response.data
}

/** Create a stage event */
export interface StageEventCreate {
  journal_contact: string
  stage: PipelineStage
  event_type: string
  notes?: string
  metadata?: Record<string, unknown>
}

export async function createStageEvent(data: StageEventCreate): Promise<StageEvent> {
  const response = await apiClient.post<StageEvent>('/journals/stage-events/', data)
  return response.data
}
```

Key patterns:
- Uses apiClient from client.ts with JWT injection
- Types match Django serializer output
- Pagination params for infinite scroll support
- stage_events endpoint uses page/page_size for DRF PageNumberPagination
  </action>
  <verify>TypeScript compiles: `cd frontend && npx tsc --noEmit`</verify>
  <done>
journals.ts exports: getJournals, getJournal, createJournal, updateJournal, archiveJournal, getJournalMembers, getStageEvents, createStageEvent
All functions typed with proper request/response interfaces
  </done>
</task>

<task type="auto">
  <name>Task 2: Create React Query hooks</name>
  <files>frontend/src/hooks/useJournals.ts</files>
  <action>
Create `frontend/src/hooks/useJournals.ts` following useContacts.ts pattern:

```typescript
import {
  useQuery,
  useMutation,
  useInfiniteQuery,
  useQueryClient,
} from "@tanstack/react-query"
import {
  getJournals,
  getJournal,
  createJournal,
  updateJournal,
  archiveJournal,
  getJournalMembers,
  getStageEvents,
  createStageEvent,
} from "@/api/journals"
import type {
  JournalFilters,
  JournalCreate,
  JournalUpdate,
  JournalMemberFilters,
  StageEventCreate,
} from "@/api/journals"
import type { PipelineStage } from "@/types/journals"

/** Hook for fetching paginated journal list */
export function useJournals(filters: JournalFilters = {}) {
  return useQuery({
    queryKey: ["journals", filters],
    queryFn: () => getJournals(filters),
  })
}

/** Hook for fetching single journal */
export function useJournal(id: string) {
  return useQuery({
    queryKey: ["journals", id],
    queryFn: () => getJournal(id),
    enabled: !!id,
  })
}

/** Hook for creating a journal */
export function useCreateJournal() {
  const queryClient = useQueryClient()

  return useMutation({
    mutationFn: (data: JournalCreate) => createJournal(data),
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: ["journals"] })
    },
  })
}

/** Hook for updating a journal */
export function useUpdateJournal() {
  const queryClient = useQueryClient()

  return useMutation({
    mutationFn: ({ id, data }: { id: string; data: JournalUpdate }) =>
      updateJournal(id, data),
    onSuccess: (_, { id }) => {
      queryClient.invalidateQueries({ queryKey: ["journals"] })
      queryClient.invalidateQueries({ queryKey: ["journals", id] })
    },
  })
}

/** Hook for archiving a journal */
export function useArchiveJournal() {
  const queryClient = useQueryClient()

  return useMutation({
    mutationFn: (id: string) => archiveJournal(id),
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: ["journals"] })
    },
  })
}

/** Hook for fetching journal members with stage event summaries */
export function useJournalMembers(
  journalId: string,
  filters: Omit<JournalMemberFilters, 'journal'> = {}
) {
  return useQuery({
    queryKey: ["journals", journalId, "members", filters],
    queryFn: () => getJournalMembers(journalId, filters),
    enabled: !!journalId,
  })
}

/**
 * Hook for fetching stage events with infinite scroll pagination.
 * Used in EventTimelineDrawer for "Load More" functionality.
 *
 * Per RESEARCH.md: useInfiniteQuery with getNextPageParam for paginated timeline.
 */
export function useStageEventsInfinite(
  journalContactId: string,
  stage?: PipelineStage,
  options: { enabled?: boolean; pageSize?: number } = {}
) {
  const { enabled = true, pageSize = 5 } = options

  return useInfiniteQuery({
    queryKey: ["stage-events", journalContactId, stage],
    queryFn: ({ pageParam = 1 }) =>
      getStageEvents({
        journalContactId,
        stage,
        page: pageParam,
        pageSize,
      }),
    getNextPageParam: (lastPage) => {
      // DRF pagination returns `next` URL if there are more pages
      if (lastPage.next) {
        // Extract page number from URL (e.g., "...?page=2")
        const url = new URL(lastPage.next)
        const nextPage = url.searchParams.get('page')
        return nextPage ? parseInt(nextPage, 10) : undefined
      }
      return undefined
    },
    initialPageParam: 1,
    enabled: enabled && !!journalContactId,
  })
}

/** Hook for creating a stage event */
export function useCreateStageEvent() {
  const queryClient = useQueryClient()

  return useMutation({
    mutationFn: (data: StageEventCreate) => createStageEvent(data),
    onSuccess: (_, variables) => {
      // Invalidate both the specific stage query and any all-events query
      queryClient.invalidateQueries({
        queryKey: ["stage-events", variables.journal_contact],
      })
      // Also invalidate journal members to update stage event summaries
      queryClient.invalidateQueries({
        queryKey: ["journals"],
        refetchType: "active",
      })
    },
  })
}
```

Key patterns:
- useInfiniteQuery for event timeline pagination (per RESEARCH.md)
- getNextPageParam parses DRF pagination URL
- Query keys follow [resource, id, sub-resource] pattern
- Cache invalidation after mutations
- enabled flag for conditional fetching (drawer open/closed)
  </action>
  <verify>TypeScript compiles: `cd frontend && npx tsc --noEmit`</verify>
  <done>
useJournals.ts exports: useJournals, useJournal, useCreateJournal, useUpdateJournal, useArchiveJournal, useJournalMembers, useStageEventsInfinite, useCreateStageEvent
useStageEventsInfinite uses useInfiniteQuery with getNextPageParam for load more
All hooks typed with proper request/response interfaces
  </done>
</task>

</tasks>

<verification>
1. TypeScript compiles: `cd frontend && npx tsc --noEmit`
2. API client exports all functions: grep "export async function" frontend/src/api/journals.ts
3. Hooks file uses useInfiniteQuery: grep "useInfiniteQuery" frontend/src/hooks/useJournals.ts
4. Query keys consistent with codebase pattern: grep "queryKey" frontend/src/hooks/useJournals.ts
</verification>

<success_criteria>
- [ ] frontend/src/api/journals.ts exports getJournals, getJournal, getJournalMembers, getStageEvents
- [ ] frontend/src/hooks/useJournals.ts exports useJournals, useJournal, useJournalMembers, useStageEventsInfinite
- [ ] useStageEventsInfinite uses useInfiniteQuery with getNextPageParam
- [ ] Query keys follow ["journals", ...] pattern matching codebase conventions
- [ ] All TypeScript compiles without errors
</success_criteria>

<output>
After completion, create `.planning/phases/04-grid-ui-core/04-02-SUMMARY.md`
</output>
