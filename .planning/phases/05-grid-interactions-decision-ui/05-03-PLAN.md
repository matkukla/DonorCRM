---
phase: 05-grid-interactions-decision-ui
plan: 03
type: execute
wave: 2
depends_on: ["05-01"]
files_modified:
  - frontend/src/api/journals.ts
  - frontend/src/hooks/useJournals.ts
  - frontend/src/types/journals.ts
  - frontend/src/pages/journals/components/JournalHeader.tsx
  - frontend/src/pages/journals/components/index.ts
autonomous: true

must_haves:
  truths:
    - "Decision updates apply optimistically (UI updates before server response)"
    - "Failed decision updates roll back to previous state"
    - "Journal header shows progress bar with percentage"
    - "Header displays total decisions count and pledged amount"
  artifacts:
    - path: "frontend/src/api/journals.ts"
      provides: "Decision CRUD API functions"
      contains: "updateDecision"
    - path: "frontend/src/hooks/useJournals.ts"
      provides: "Optimistic decision mutation hooks"
      contains: "useUpdateDecision"
    - path: "frontend/src/pages/journals/components/JournalHeader.tsx"
      provides: "Journal header with progress stats"
      contains: "JournalHeader"
  key_links:
    - from: "frontend/src/hooks/useJournals.ts"
      to: "frontend/src/api/journals.ts"
      via: "mutation function import"
      pattern: "import.*updateDecision.*from.*api/journals"
    - from: "frontend/src/pages/journals/components/JournalHeader.tsx"
      to: "frontend/src/components/ui/progress.tsx"
      via: "Progress component import"
      pattern: "import.*Progress.*from.*ui/progress"
---

<objective>
Add decision mutation hooks with optimistic updates and create JournalHeader component with progress tracking.

Purpose: This is the core data layer for Phase 5. Optimistic updates provide instant feedback (critical pitfall from STATE.md), and JournalHeader satisfies JRN-14 requirements.

Output: Decision API functions, mutation hooks with rollback, JournalHeader component with real-time stats.
</objective>

<execution_context>
@/home/matkukla/.claude/get-shit-done/workflows/execute-plan.md
@/home/matkukla/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/05-grid-interactions-decision-ui/05-RESEARCH.md

# Existing API and hooks patterns
@frontend/src/api/journals.ts
@frontend/src/hooks/useJournals.ts
@frontend/src/hooks/usePledges.ts
@frontend/src/types/journals.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add decision API functions and types</name>
  <files>
frontend/src/api/journals.ts
frontend/src/types/journals.ts
  </files>
  <action>
**1. Add types to frontend/src/types/journals.ts:**

Add after DecisionSummary interface:

```typescript
/** Full decision detail from API */
export interface DecisionDetail {
  id: string
  journal_contact: string
  amount: string
  cadence: DecisionCadence
  status: DecisionStatus
  monthly_equivalent: string
  created_at: string
  updated_at: string
}

/** Decision create payload */
export interface DecisionCreate {
  journal_contact: string
  amount: string
  cadence: DecisionCadence
  status: DecisionStatus
}

/** Decision update payload (partial) */
export interface DecisionUpdate {
  amount?: string
  cadence?: DecisionCadence
  status?: DecisionStatus
}

/** Decision status display colors */
export const DECISION_STATUS_COLORS: Record<DecisionStatus, string> = {
  pending: 'warning',
  active: 'success',
  paused: 'secondary',
  declined: 'destructive',
}

/** Decision cadence labels for display */
export const CADENCE_LABELS: Record<DecisionCadence, string> = {
  one_time: 'One-Time',
  monthly: 'Monthly',
  quarterly: 'Quarterly',
  annual: 'Annual',
}

/** Decision status labels for display */
export const STATUS_LABELS: Record<DecisionStatus, string> = {
  pending: 'Pending',
  active: 'Active',
  paused: 'Paused',
  declined: 'Declined',
}
```

**2. Add decision API functions to frontend/src/api/journals.ts:**

Add imports at top:
```typescript
import type {
  // ... existing imports
  DecisionDetail,
  DecisionCreate,
  DecisionUpdate,
} from "@/types/journals"
```

Add after createStageEvent function:

```typescript
/** Create a decision for a journal contact */
export async function createDecision(data: DecisionCreate): Promise<DecisionDetail> {
  const response = await apiClient.post<DecisionDetail>('/journals/decisions/', data)
  return response.data
}

/** Update a decision (triggers history tracking on backend) */
export async function updateDecision(
  id: string,
  data: DecisionUpdate
): Promise<DecisionDetail> {
  const response = await apiClient.patch<DecisionDetail>(
    `/journals/decisions/${id}/`,
    data
  )
  return response.data
}

/** Delete a decision */
export async function deleteDecision(id: string): Promise<void> {
  await apiClient.delete(`/journals/decisions/${id}/`)
}

/** Get a single decision */
export async function getDecision(id: string): Promise<DecisionDetail> {
  const response = await apiClient.get<DecisionDetail>(`/journals/decisions/${id}/`)
  return response.data
}
```
  </action>
  <verify>
```bash
cd /home/matkukla/projects/DonorCRM/frontend && npx tsc --noEmit
```
No TypeScript errors.
  </verify>
  <done>
- DecisionDetail, DecisionCreate, DecisionUpdate types exported
- DECISION_STATUS_COLORS, CADENCE_LABELS, STATUS_LABELS constants exported
- createDecision, updateDecision, deleteDecision, getDecision functions exported
  </done>
</task>

<task type="auto">
  <name>Task 2: Add optimistic decision mutation hooks</name>
  <files>frontend/src/hooks/useJournals.ts</files>
  <action>
Add optimistic update mutation hooks to useJournals.ts. Follow RESEARCH.md Pattern 1 exactly.

Add imports at top:
```typescript
import {
  createDecision,
  updateDecision,
  deleteDecision,
} from "@/api/journals"
import type {
  DecisionCreate,
  DecisionUpdate,
  JournalMember,
} from "@/types/journals"
import { toast } from "sonner"
```

Add PaginatedResponse type if not present:
```typescript
interface PaginatedResponse<T> {
  count: number
  next: string | null
  previous: string | null
  results: T[]
}
```

Add after useCreateStageEvent hook:

```typescript
/**
 * Hook for creating a decision with cache update.
 * After creation, invalidates members list to show new decision.
 */
export function useCreateDecision(journalId: string) {
  const queryClient = useQueryClient()

  return useMutation({
    mutationFn: (data: DecisionCreate) => createDecision(data),
    onSuccess: () => {
      toast.success("Decision created")
      // Invalidate members to refetch with new decision
      queryClient.invalidateQueries({
        queryKey: ["journals", journalId, "members"],
      })
    },
    onError: () => {
      toast.error("Failed to create decision")
    },
  })
}

/**
 * Hook for updating a decision with optimistic updates.
 *
 * Critical pattern from STATE.md:
 * "Optimistic update rollback on error (use React Query mutation onError callbacks)"
 *
 * Flow:
 * 1. onMutate: Cancel queries, snapshot cache, optimistically update
 * 2. onError: Rollback to snapshot
 * 3. onSettled: Invalidate to sync with server
 */
export function useUpdateDecision(journalId: string) {
  const queryClient = useQueryClient()

  return useMutation({
    mutationFn: ({ id, data }: { id: string; data: DecisionUpdate }) =>
      updateDecision(id, data),

    onMutate: async ({ id, data }) => {
      // 1. Cancel outgoing refetches to avoid overwriting optimistic update
      await queryClient.cancelQueries({
        queryKey: ["journals", journalId, "members"],
      })

      // 2. Snapshot current cache for rollback
      const previousMembers = queryClient.getQueryData<PaginatedResponse<JournalMember>>(
        ["journals", journalId, "members", {}]
      )

      // 3. Optimistically update the cache
      if (previousMembers) {
        queryClient.setQueryData<PaginatedResponse<JournalMember>>(
          ["journals", journalId, "members", {}],
          (old) => {
            if (!old) return old
            return {
              ...old,
              results: old.results.map((member) => {
                if (member.decision?.id === id) {
                  return {
                    ...member,
                    decision: { ...member.decision, ...data },
                  }
                }
                return member
              }),
            }
          }
        )
      }

      // 4. Return context with snapshot for rollback
      return { previousMembers }
    },

    onError: (err, variables, context) => {
      // Rollback to snapshot on error
      if (context?.previousMembers) {
        queryClient.setQueryData(
          ["journals", journalId, "members", {}],
          context.previousMembers
        )
      }
      toast.error("Failed to update decision")
    },

    onSuccess: () => {
      toast.success("Decision updated")
    },

    onSettled: () => {
      // Always refetch to ensure cache matches server
      queryClient.invalidateQueries({
        queryKey: ["journals", journalId, "members"],
      })
    },
  })
}

/**
 * Hook for deleting a decision with optimistic removal.
 */
export function useDeleteDecision(journalId: string) {
  const queryClient = useQueryClient()

  return useMutation({
    mutationFn: (id: string) => deleteDecision(id),

    onMutate: async (id) => {
      await queryClient.cancelQueries({
        queryKey: ["journals", journalId, "members"],
      })

      const previousMembers = queryClient.getQueryData<PaginatedResponse<JournalMember>>(
        ["journals", journalId, "members", {}]
      )

      if (previousMembers) {
        queryClient.setQueryData<PaginatedResponse<JournalMember>>(
          ["journals", journalId, "members", {}],
          (old) => {
            if (!old) return old
            return {
              ...old,
              results: old.results.map((member) => {
                if (member.decision?.id === id) {
                  return { ...member, decision: null }
                }
                return member
              }),
            }
          }
        )
      }

      return { previousMembers }
    },

    onError: (err, variables, context) => {
      if (context?.previousMembers) {
        queryClient.setQueryData(
          ["journals", journalId, "members", {}],
          context.previousMembers
        )
      }
      toast.error("Failed to delete decision")
    },

    onSuccess: () => {
      toast.success("Decision deleted")
    },

    onSettled: () => {
      queryClient.invalidateQueries({
        queryKey: ["journals", journalId, "members"],
      })
    },
  })
}
```
  </action>
  <verify>
```bash
cd /home/matkukla/projects/DonorCRM/frontend && npx tsc --noEmit
```
No TypeScript errors.
  </verify>
  <done>
- useCreateDecision hook with success toast
- useUpdateDecision hook with optimistic updates and rollback
- useDeleteDecision hook with optimistic removal and rollback
  </done>
</task>

<task type="auto">
  <name>Task 3: Create JournalHeader component</name>
  <files>
frontend/src/pages/journals/components/JournalHeader.tsx
frontend/src/pages/journals/components/index.ts
  </files>
  <action>
**1. Create JournalHeader.tsx:**

```typescript
import * as React from "react"
import { Progress } from "@/components/ui/progress"
import type { JournalDetail, JournalMember, DecisionSummary } from "@/types/journals"

export interface JournalHeaderProps {
  /** Journal details */
  journal: JournalDetail
  /** Journal members for stats calculation */
  members: JournalMember[]
}

/**
 * Journal header displaying name, goal, progress bar, and aggregated stats.
 *
 * Per JRN-14:
 * - Header shows journal name, goal amount, current progress bar
 * - Shows total decisions made (count) and total amount pledged
 * - Shows percentage toward goal
 *
 * Stats are memoized to prevent cascade re-renders when individual cells update.
 */
export function JournalHeader({ journal, members }: JournalHeaderProps) {
  // Calculate stats from cached member data
  // Memoize to prevent re-renders (per Phase 5 success criteria #7)
  const stats = React.useMemo(() => {
    // Filter to non-declined decisions
    const decisions = members
      .map((m) => m.decision)
      .filter((d): d is DecisionSummary => d !== null && d.status !== 'declined')

    // Sum total pledged (raw amounts, not monthly equivalent)
    const totalPledged = decisions.reduce(
      (sum, d) => sum + parseFloat(d.amount),
      0
    )

    // Sum monthly equivalent for recurring view
    const totalMonthly = decisions.reduce(
      (sum, d) => sum + parseFloat(d.monthly_equivalent),
      0
    )

    // Count of decisions made
    const decisionCount = decisions.length

    // Progress toward goal
    const goalAmount = parseFloat(journal.goal_amount)
    const progressPercent = goalAmount > 0
      ? Math.min((totalPledged / goalAmount) * 100, 100)
      : 0

    return { totalPledged, totalMonthly, decisionCount, progressPercent }
  }, [members, journal.goal_amount])

  return (
    <div className="space-y-4 p-4 bg-card rounded-lg border">
      {/* Title and stats row */}
      <div className="flex items-start justify-between">
        <div>
          <h1 className="text-2xl font-bold">{journal.name}</h1>
          <p className="text-muted-foreground">
            Goal: ${parseFloat(journal.goal_amount).toLocaleString()}
            {journal.deadline && (
              <span> &bull; Due {new Date(journal.deadline).toLocaleDateString()}</span>
            )}
          </p>
        </div>
        <div className="text-right text-sm space-y-1">
          <p className="text-muted-foreground">
            {stats.decisionCount} {stats.decisionCount === 1 ? 'decision' : 'decisions'} made
          </p>
          <p className="font-semibold text-lg">
            ${stats.totalPledged.toLocaleString()} pledged
          </p>
          {stats.totalMonthly > 0 && (
            <p className="text-xs text-muted-foreground">
              ${stats.totalMonthly.toLocaleString()}/mo recurring
            </p>
          )}
        </div>
      </div>

      {/* Progress bar */}
      <div className="space-y-2">
        <Progress value={stats.progressPercent} className="h-3" />
        <p className="text-xs text-muted-foreground text-center">
          {stats.progressPercent.toFixed(0)}% of goal
        </p>
      </div>
    </div>
  )
}
```

**2. Update barrel export in index.ts:**

Add to existing exports:
```typescript
export { JournalHeader } from './JournalHeader'
```
  </action>
  <verify>
```bash
cd /home/matkukla/projects/DonorCRM/frontend && npx tsc --noEmit
```
No TypeScript errors.
  </verify>
  <done>
- JournalHeader component with memoized stats calculation
- Shows: journal name, goal amount, deadline, decision count, total pledged, monthly recurring
- Progress bar with percentage toward goal
- Exported from components/index.ts
  </done>
</task>

</tasks>

<verification>
1. TypeScript compiles: `cd frontend && npx tsc --noEmit`
2. API functions exported: `grep -E "export.*(createDecision|updateDecision)" frontend/src/api/journals.ts`
3. Hooks exported: `grep -E "export.*use(Create|Update|Delete)Decision" frontend/src/hooks/useJournals.ts`
4. JournalHeader exists: `grep "export.*JournalHeader" frontend/src/pages/journals/components/JournalHeader.tsx`
5. Barrel export: `grep "JournalHeader" frontend/src/pages/journals/components/index.ts`
</verification>

<success_criteria>
- Decision types (DecisionDetail, DecisionCreate, DecisionUpdate) in types/journals.ts
- Decision API functions (create, update, delete, get) in api/journals.ts
- Optimistic mutation hooks with proper rollback pattern in useJournals.ts
- JournalHeader component with memoized stats and Progress bar
- All TypeScript compiles without errors
</success_criteria>

<output>
After completion, create `.planning/phases/05-grid-interactions-decision-ui/05-03-SUMMARY.md`
</output>
