---
phase: 05-grid-interactions-decision-ui
plan: 04
type: execute
wave: 2
depends_on: ["05-01", "05-02"]
files_modified:
  - frontend/src/api/journals.ts
  - frontend/src/hooks/useJournals.ts
  - frontend/src/types/journals.ts
  - frontend/src/pages/journals/components/StageCell.tsx
  - frontend/src/pages/journals/components/NextStepsCell.tsx
  - frontend/src/pages/journals/components/index.ts
autonomous: true

must_haves:
  truths:
    - "Warning toast appears when skipping or reversing pipeline stages"
    - "Stage movement proceeds despite warning (no hard block)"
    - "User can view next steps count in grid cell"
    - "User can toggle next step completion via popover"
  artifacts:
    - path: "frontend/src/pages/journals/components/StageCell.tsx"
      provides: "Stage cell with movement warning logic"
      contains: "checkStageTransition"
    - path: "frontend/src/pages/journals/components/NextStepsCell.tsx"
      provides: "Next steps checklist cell"
      contains: "NextStepsCell"
    - path: "frontend/src/api/journals.ts"
      provides: "NextStep API functions"
      contains: "updateNextStep"
  key_links:
    - from: "frontend/src/pages/journals/components/StageCell.tsx"
      to: "sonner"
      via: "toast import"
      pattern: "import.*toast.*from.*sonner"
    - from: "frontend/src/pages/journals/components/NextStepsCell.tsx"
      to: "frontend/src/hooks/useJournals.ts"
      via: "useUpdateNextStep hook"
      pattern: "useUpdateNextStep"
---

<objective>
Add stage movement warnings and NextSteps frontend integration.

Purpose: JRN-05 requires non-sequential stage movement warnings (but no hard blocks). JRN-06 requires next steps checklist visible in journal grid.

Output: Enhanced StageCell with warnings, NextStepsCell component, NextStep API and hooks.
</objective>

<execution_context>
@/home/matkukla/.claude/get-shit-done/workflows/execute-plan.md
@/home/matkukla/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/05-grid-interactions-decision-ui/05-RESEARCH.md

# Existing components
@frontend/src/pages/journals/components/StageCell.tsx
@frontend/src/types/journals.ts
@frontend/src/hooks/useJournals.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add NextStep types, API functions, and hooks</name>
  <files>
frontend/src/types/journals.ts
frontend/src/api/journals.ts
frontend/src/hooks/useJournals.ts
  </files>
  <action>
**1. Add NextStep types to types/journals.ts:**

Add after STATUS_LABELS:

```typescript
/** Next step item for checklist */
export interface NextStep {
  id: string
  journal_contact: string
  title: string
  notes: string
  due_date: string | null
  completed: boolean
  completed_at: string | null
  order: number
  created_at: string
  updated_at: string
}

/** Next step create payload */
export interface NextStepCreate {
  journal_contact: string
  title: string
  notes?: string
  due_date?: string | null
  order?: number
}

/** Next step update payload */
export interface NextStepUpdate {
  title?: string
  notes?: string
  due_date?: string | null
  completed?: boolean
  order?: number
}

/** Stage transition check result */
export interface StageTransitionCheck {
  isSequential: boolean
  skippedStages: string[]
  isRevisiting: boolean
}

/** Stage order for transition checking */
export const STAGE_ORDER: Record<PipelineStage, number> = {
  contact: 1,
  meet: 2,
  close: 3,
  decision: 4,
  thank: 5,
  next_steps: 6,
}

/**
 * Check if a stage transition is sequential.
 * Per JRN-05: "System shows subtle warnings for non-sequential movement (no hard blocks)"
 */
export function checkStageTransition(
  currentStage: PipelineStage | null,
  targetStage: PipelineStage
): StageTransitionCheck {
  // If no current stage, any movement is allowed
  if (!currentStage) {
    return { isSequential: true, skippedStages: [], isRevisiting: false }
  }

  const currentOrder = STAGE_ORDER[currentStage]
  const targetOrder = STAGE_ORDER[targetStage]

  // Going backwards = revisiting
  if (targetOrder < currentOrder) {
    return {
      isSequential: false,
      skippedStages: [],
      isRevisiting: true,
    }
  }

  // Skipping forward
  if (targetOrder > currentOrder + 1) {
    const skipped = Object.entries(STAGE_ORDER)
      .filter(([_, order]) => order > currentOrder && order < targetOrder)
      .map(([stage]) => STAGE_LABELS[stage as PipelineStage])
    return {
      isSequential: false,
      skippedStages: skipped,
      isRevisiting: false,
    }
  }

  // Sequential movement
  return { isSequential: true, skippedStages: [], isRevisiting: false }
}
```

**2. Add NextStep API functions to api/journals.ts:**

Add imports:
```typescript
import type { NextStep, NextStepCreate, NextStepUpdate } from "@/types/journals"
```

Add after decision API functions:

```typescript
/** Get next steps for a journal contact */
export async function getNextSteps(
  journalContactId: string
): Promise<PaginatedResponse<NextStep>> {
  const response = await apiClient.get<PaginatedResponse<NextStep>>(
    `/journals/next-steps/?journal_contact=${journalContactId}`
  )
  return response.data
}

/** Create a next step */
export async function createNextStep(data: NextStepCreate): Promise<NextStep> {
  const response = await apiClient.post<NextStep>('/journals/next-steps/', data)
  return response.data
}

/** Update a next step */
export async function updateNextStep(
  id: string,
  data: NextStepUpdate
): Promise<NextStep> {
  const response = await apiClient.patch<NextStep>(
    `/journals/next-steps/${id}/`,
    data
  )
  return response.data
}

/** Delete a next step */
export async function deleteNextStep(id: string): Promise<void> {
  await apiClient.delete(`/journals/next-steps/${id}/`)
}
```

**3. Add NextStep hooks to useJournals.ts:**

Add imports:
```typescript
import {
  getNextSteps,
  createNextStep,
  updateNextStep,
  deleteNextStep,
} from "@/api/journals"
import type { NextStep, NextStepCreate, NextStepUpdate } from "@/types/journals"
```

Add hooks:

```typescript
/** Hook for fetching next steps for a journal contact */
export function useNextSteps(journalContactId: string, options?: { enabled?: boolean }) {
  return useQuery({
    queryKey: ["next-steps", journalContactId],
    queryFn: () => getNextSteps(journalContactId),
    enabled: options?.enabled !== false && !!journalContactId,
  })
}

/** Hook for creating a next step */
export function useCreateNextStep(journalContactId: string) {
  const queryClient = useQueryClient()

  return useMutation({
    mutationFn: (data: NextStepCreate) => createNextStep(data),
    onSuccess: () => {
      toast.success("Next step created")
      queryClient.invalidateQueries({
        queryKey: ["next-steps", journalContactId],
      })
    },
    onError: () => {
      toast.error("Failed to create next step")
    },
  })
}

/** Hook for updating a next step with optimistic toggle */
export function useUpdateNextStep(journalContactId: string) {
  const queryClient = useQueryClient()

  return useMutation({
    mutationFn: ({ id, data }: { id: string; data: NextStepUpdate }) =>
      updateNextStep(id, data),

    onMutate: async ({ id, data }) => {
      await queryClient.cancelQueries({
        queryKey: ["next-steps", journalContactId],
      })

      const previousSteps = queryClient.getQueryData<PaginatedResponse<NextStep>>(
        ["next-steps", journalContactId]
      )

      if (previousSteps) {
        queryClient.setQueryData<PaginatedResponse<NextStep>>(
          ["next-steps", journalContactId],
          (old) => {
            if (!old) return old
            return {
              ...old,
              results: old.results.map((step) =>
                step.id === id ? { ...step, ...data } : step
              ),
            }
          }
        )
      }

      return { previousSteps }
    },

    onError: (err, variables, context) => {
      if (context?.previousSteps) {
        queryClient.setQueryData(
          ["next-steps", journalContactId],
          context.previousSteps
        )
      }
      toast.error("Failed to update next step")
    },

    onSettled: () => {
      queryClient.invalidateQueries({
        queryKey: ["next-steps", journalContactId],
      })
    },
  })
}

/** Hook for deleting a next step */
export function useDeleteNextStep(journalContactId: string) {
  const queryClient = useQueryClient()

  return useMutation({
    mutationFn: (id: string) => deleteNextStep(id),
    onSuccess: () => {
      toast.success("Next step deleted")
      queryClient.invalidateQueries({
        queryKey: ["next-steps", journalContactId],
      })
    },
    onError: () => {
      toast.error("Failed to delete next step")
    },
  })
}
```
  </action>
  <verify>
```bash
cd /home/matkukla/projects/DonorCRM/frontend && npx tsc --noEmit
```
No TypeScript errors.
  </verify>
  <done>
- NextStep, NextStepCreate, NextStepUpdate types
- checkStageTransition function with STAGE_ORDER
- NextStep API functions (get, create, update, delete)
- NextStep hooks (useNextSteps, useCreateNextStep, useUpdateNextStep, useDeleteNextStep)
  </done>
</task>

<task type="auto">
  <name>Task 2: Enhance StageCell with movement warnings</name>
  <files>frontend/src/pages/journals/components/StageCell.tsx</files>
  <action>
Update StageCell to show warning toasts for non-sequential stage movement.

The cell already handles clicks to open the timeline drawer. When creating a stage event that moves to a new stage, we need to check if it's sequential.

Read the existing StageCell.tsx first, then update it to:

1. Import toast and checkStageTransition:
```typescript
import { toast } from "sonner"
import {
  checkStageTransition,
  STAGE_LABELS,
  // ... existing imports
} from "@/types/journals"
```

2. Add a prop for current stage (the highest stage with events):
```typescript
export interface StageCellProps {
  // ... existing props
  /** Current highest stage for this contact (for transition warnings) */
  currentStage?: PipelineStage | null
}
```

3. Add a helper function to get highest stage with events (put outside component or as utility):
```typescript
/**
 * Get the highest pipeline stage that has events.
 * Used to determine current stage for transition warnings.
 */
export function getHighestStageWithEvents(
  stageEvents: Record<PipelineStage, StageEventSummary>
): PipelineStage | null {
  const stages: PipelineStage[] = ['next_steps', 'thank', 'decision', 'close', 'meet', 'contact']
  for (const stage of stages) {
    if (stageEvents[stage]?.has_events) {
      return stage
    }
  }
  return null
}
```

4. When cell is clicked, before calling onCellClick, check transition and show warning:
```typescript
const handleClick = React.useCallback(() => {
  // Check if this would be a non-sequential transition
  if (currentStage && stage !== currentStage) {
    const transition = checkStageTransition(currentStage, stage)
    if (!transition.isSequential) {
      if (transition.isRevisiting) {
        toast.warning("Revisiting stage", {
          description: `Moving back to ${STAGE_LABELS[stage]}`,
        })
      } else if (transition.skippedStages.length > 0) {
        toast.warning("Skipping stages", {
          description: `Skipping: ${transition.skippedStages.join(", ")}`,
        })
      }
    }
  }
  // Always proceed - no hard block (per JRN-05)
  onCellClick(contactId, stage)
}, [contactId, stage, currentStage, onCellClick])
```

Note: The warning fires when clicking the cell to view/add events. The actual stage event creation happens in the drawer, but this gives early feedback about the transition.
  </action>
  <verify>
```bash
cd /home/matkukla/projects/DonorCRM/frontend && npx tsc --noEmit
```
No TypeScript errors.
  </verify>
  <done>
- StageCell imports toast and checkStageTransition
- getHighestStageWithEvents helper function added
- Click handler shows warning toast for non-sequential transitions
- Transitions always proceed (no hard block)
  </done>
</task>

<task type="auto">
  <name>Task 3: Create NextStepsCell component</name>
  <files>
frontend/src/pages/journals/components/NextStepsCell.tsx
frontend/src/pages/journals/components/index.ts
  </files>
  <action>
**1. Create NextStepsCell.tsx:**

```typescript
import * as React from "react"
import { CheckSquare, Plus, Trash2 } from "lucide-react"
import { Button } from "@/components/ui/button"
import { Checkbox } from "@/components/ui/checkbox"
import { Input } from "@/components/ui/input"
import {
  Popover,
  PopoverContent,
  PopoverTrigger,
} from "@/components/ui/popover"
import { useNextSteps, useCreateNextStep, useUpdateNextStep, useDeleteNextStep } from "@/hooks/useJournals"
import type { NextStep } from "@/types/journals"

export interface NextStepsCellProps {
  /** Journal contact ID to fetch/manage next steps */
  journalContactId: string
}

/**
 * Next steps checklist cell for the journal grid.
 *
 * Per JRN-06:
 * - User can create, edit, and mark complete checklist items per contact per journal
 * - Next Steps are independent items (not single boolean)
 * - Visible in journal grid
 *
 * Shows count badge, opens popover with full checklist on click.
 */
export const NextStepsCell = React.memo(function NextStepsCell({
  journalContactId,
}: NextStepsCellProps) {
  const [isOpen, setIsOpen] = React.useState(false)
  const [newStepTitle, setNewStepTitle] = React.useState("")

  // Fetch next steps only when popover is open
  const { data: stepsData, isLoading } = useNextSteps(journalContactId, {
    enabled: isOpen,
  })

  const createMutation = useCreateNextStep(journalContactId)
  const updateMutation = useUpdateNextStep(journalContactId)
  const deleteMutation = useDeleteNextStep(journalContactId)

  const steps = stepsData?.results ?? []
  const completedCount = steps.filter((s) => s.completed).length
  const totalCount = steps.length

  const handleToggle = React.useCallback(
    (step: NextStep) => {
      updateMutation.mutate({
        id: step.id,
        data: { completed: !step.completed },
      })
    },
    [updateMutation]
  )

  const handleCreate = React.useCallback(() => {
    if (!newStepTitle.trim()) return
    createMutation.mutate(
      {
        journal_contact: journalContactId,
        title: newStepTitle.trim(),
      },
      {
        onSuccess: () => setNewStepTitle(""),
      }
    )
  }, [journalContactId, newStepTitle, createMutation])

  const handleKeyDown = React.useCallback(
    (e: React.KeyboardEvent) => {
      if (e.key === "Enter") {
        e.preventDefault()
        handleCreate()
      }
    },
    [handleCreate]
  )

  const handleDelete = React.useCallback(
    (stepId: string) => {
      deleteMutation.mutate(stepId)
    },
    [deleteMutation]
  )

  return (
    <Popover open={isOpen} onOpenChange={setIsOpen}>
      <PopoverTrigger asChild>
        <button
          className="flex items-center gap-1 text-sm px-2 py-1 rounded hover:bg-accent transition-colors"
          aria-label={`${completedCount} of ${totalCount} next steps complete`}
        >
          <CheckSquare className="h-4 w-4" />
          {totalCount > 0 ? (
            <span className="tabular-nums">
              {completedCount}/{totalCount}
            </span>
          ) : (
            <span className="text-muted-foreground">0</span>
          )}
        </button>
      </PopoverTrigger>
      <PopoverContent className="w-72" align="start">
        <div className="space-y-3">
          <h4 className="font-medium text-sm">Next Steps</h4>

          {isLoading ? (
            <p className="text-sm text-muted-foreground">Loading...</p>
          ) : steps.length === 0 ? (
            <p className="text-sm text-muted-foreground">No next steps yet</p>
          ) : (
            <ul className="space-y-2">
              {steps.map((step) => (
                <li key={step.id} className="flex items-start gap-2 group">
                  <Checkbox
                    checked={step.completed}
                    onCheckedChange={() => handleToggle(step)}
                    className="mt-0.5"
                    disabled={updateMutation.isPending}
                  />
                  <span
                    className={
                      step.completed
                        ? "line-through text-muted-foreground flex-1 text-sm"
                        : "flex-1 text-sm"
                    }
                  >
                    {step.title}
                  </span>
                  <button
                    onClick={() => handleDelete(step.id)}
                    className="opacity-0 group-hover:opacity-100 text-muted-foreground hover:text-destructive transition-opacity"
                    aria-label="Delete step"
                    disabled={deleteMutation.isPending}
                  >
                    <Trash2 className="h-3 w-3" />
                  </button>
                </li>
              ))}
            </ul>
          )}

          {/* Add new step */}
          <div className="flex gap-2 pt-2 border-t">
            <Input
              value={newStepTitle}
              onChange={(e) => setNewStepTitle(e.target.value)}
              onKeyDown={handleKeyDown}
              placeholder="Add a step..."
              className="h-8 text-sm"
              disabled={createMutation.isPending}
            />
            <Button
              size="sm"
              variant="ghost"
              onClick={handleCreate}
              disabled={!newStepTitle.trim() || createMutation.isPending}
              className="h-8 px-2"
            >
              <Plus className="h-4 w-4" />
            </Button>
          </div>
        </div>
      </PopoverContent>
    </Popover>
  )
})
```

Note: This uses the existing Popover component. If it doesn't exist, we need to add it first. Check if it exists, and if not, create a simple wrapper around @radix-ui/react-popover.

**2. Check if Popover exists, create if needed:**

Check: `ls frontend/src/components/ui/popover.tsx`

If it doesn't exist, create frontend/src/components/ui/popover.tsx:

```typescript
"use client"

import * as React from "react"
import * as PopoverPrimitive from "@radix-ui/react-popover"
import { cn } from "@/lib/utils"

const Popover = PopoverPrimitive.Root
const PopoverTrigger = PopoverPrimitive.Trigger
const PopoverAnchor = PopoverPrimitive.Anchor

const PopoverContent = React.forwardRef<
  React.ElementRef<typeof PopoverPrimitive.Content>,
  React.ComponentPropsWithoutRef<typeof PopoverPrimitive.Content>
>(({ className, align = "center", sideOffset = 4, ...props }, ref) => (
  <PopoverPrimitive.Portal>
    <PopoverPrimitive.Content
      ref={ref}
      align={align}
      sideOffset={sideOffset}
      className={cn(
        "z-50 w-72 rounded-md border bg-popover p-4 text-popover-foreground shadow-md outline-none data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2",
        className
      )}
      {...props}
    />
  </PopoverPrimitive.Portal>
))
PopoverContent.displayName = PopoverPrimitive.Content.displayName

export { Popover, PopoverTrigger, PopoverContent, PopoverAnchor }
```

And install: `cd frontend && npm install @radix-ui/react-popover`

**3. Update barrel export in index.ts:**

Add:
```typescript
export { NextStepsCell } from './NextStepsCell'
export { getHighestStageWithEvents } from './StageCell'
```
  </action>
  <verify>
```bash
cd /home/matkukla/projects/DonorCRM/frontend && npx tsc --noEmit
```
No TypeScript errors.
  </verify>
  <done>
- NextStepsCell component with popover checklist
- Toggle completion via checkbox
- Add new step via input
- Delete step via trash icon
- Memoized to prevent cascade re-renders
- Exported from index.ts
  </done>
</task>

</tasks>

<verification>
1. TypeScript compiles: `cd frontend && npx tsc --noEmit`
2. NextStep types: `grep "interface NextStep" frontend/src/types/journals.ts`
3. checkStageTransition: `grep "checkStageTransition" frontend/src/types/journals.ts`
4. NextStep API: `grep -E "export.*(createNextStep|updateNextStep)" frontend/src/api/journals.ts`
5. NextStep hooks: `grep -E "export.*useNextSteps" frontend/src/hooks/useJournals.ts`
6. StageCell warning: `grep "toast.warning" frontend/src/pages/journals/components/StageCell.tsx`
7. NextStepsCell: `grep "NextStepsCell" frontend/src/pages/journals/components/NextStepsCell.tsx`
</verification>

<success_criteria>
- NextStep types and checkStageTransition function in types/journals.ts
- NextStep API functions in api/journals.ts
- NextStep hooks with optimistic updates in useJournals.ts
- StageCell shows warning toast for non-sequential transitions (but allows save)
- NextStepsCell component with popover checklist, toggle, add, delete
- All TypeScript compiles
</success_criteria>

<output>
After completion, create `.planning/phases/05-grid-interactions-decision-ui/05-04-SUMMARY.md`
</output>
