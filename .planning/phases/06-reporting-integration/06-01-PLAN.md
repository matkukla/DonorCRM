---
phase: 06-reporting-integration
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - apps/journals/views.py
  - apps/journals/urls.py
autonomous: true

must_haves:
  truths:
    - "GET /api/v1/journals/analytics/decision-trends/ returns monthly decision counts"
    - "GET /api/v1/journals/analytics/stage-activity/ returns event counts by stage over time"
    - "GET /api/v1/journals/analytics/pipeline-breakdown/ returns contact counts by current stage"
    - "GET /api/v1/journals/analytics/next-steps-queue/ returns upcoming next steps across journals"
    - "Admin endpoint returns cross-missionary aggregation data"
  artifacts:
    - path: "apps/journals/views.py"
      provides: "Analytics ViewSet with 5 action endpoints"
      contains: "@action(detail=False"
  key_links:
    - from: "apps/journals/urls.py"
      to: "JournalAnalyticsViewSet"
      via: "DefaultRouter registration"
      pattern: "router.register.*analytics"
---

<objective>
Create Django analytics API endpoints for journal reporting.

Purpose: Provides backend data for Report tab charts and admin cross-missionary analytics per JRN-15 and JRN-19.
Output: Five analytics endpoints returning aggregated data optimized for chart rendering.
</objective>

<execution_context>
@/home/matkukla/.claude/get-shit-done/workflows/execute-plan.md
@/home/matkukla/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/06-reporting-integration/06-RESEARCH.md

@apps/journals/models.py
@apps/journals/views.py
@apps/journals/urls.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add decision trends analytics endpoint</name>
  <files>apps/journals/views.py</files>
  <action>
Add JournalAnalyticsViewSet with decision_trends action:

1. Create new ViewSet class JournalAnalyticsViewSet(viewsets.ViewSet)
2. Add @action(detail=False, methods=['get'], url_path='decision-trends')
3. Query Decision model with filter(journal_contact__journal__owner=request.user)
4. Use TruncMonth('created_at') to group by month
5. Annotate with Count('id')
6. Return list of {month: 'YYYY-MM', count: N}

Key implementation from RESEARCH.md:
```python
from django.db.models.functions import TruncMonth
from django.db.models import Count

@action(detail=False, methods=['get'], url_path='decision-trends')
def decision_trends(self, request):
    """Decision counts over time (bar chart data)."""
    trends = Decision.objects.filter(
        journal_contact__journal__owner=request.user
    ).annotate(
        month=TruncMonth('created_at')
    ).values('month').annotate(
        count=Count('id')
    ).order_by('month')

    return Response([
        {'month': item['month'].strftime('%Y-%m'), 'count': item['count']}
        for item in trends
    ])
```

Use select_related/prefetch_related is NOT needed here - aggregate queries don't N+1.
  </action>
  <verify>curl localhost:8000/api/v1/journals/analytics/decision-trends/ returns JSON array with month/count objects</verify>
  <done>Decision trends endpoint returns monthly aggregated decision counts</done>
</task>

<task type="auto">
  <name>Task 2: Add stage activity and pipeline breakdown endpoints</name>
  <files>apps/journals/views.py</files>
  <action>
Add two more analytics actions to JournalAnalyticsViewSet:

1. stage_activity action (@action url_path='stage-activity'):
   - Query JournalStageEvent with filter(journal_contact__journal__owner=request.user)
   - Use TruncMonth('created_at') and group by stage
   - Return list of {date: 'YYYY-MM', contact: N, meet: N, close: N, decision: N, thank: N, next_steps: N}
   - Pivot data so each month has all stage counts (use dict comprehension)

2. pipeline_breakdown action (@action url_path='pipeline-breakdown'):
   - This needs current stage per contact - use subquery or annotation
   - Query JournalContact for user's journals
   - For each contact, determine "current stage" = stage with most recent event
   - Group by current stage, count contacts
   - Return list of {stage: 'contact', count: N}

Implementation for pipeline_breakdown:
```python
from django.db.models import OuterRef, Subquery, Max

@action(detail=False, methods=['get'], url_path='pipeline-breakdown')
def pipeline_breakdown(self, request):
    """Contacts by current pipeline stage (pie chart data)."""
    # Subquery to get most recent stage per journal_contact
    latest_stage = JournalStageEvent.objects.filter(
        journal_contact=OuterRef('pk')
    ).order_by('-created_at').values('stage')[:1]

    breakdown = JournalContact.objects.filter(
        journal__owner=request.user
    ).annotate(
        current_stage=Subquery(latest_stage)
    ).values('current_stage').annotate(
        count=Count('id')
    ).order_by('current_stage')

    return Response([
        {'stage': item['current_stage'] or 'contact', 'count': item['count']}
        for item in breakdown
    ])
```
  </action>
  <verify>curl stage-activity and pipeline-breakdown endpoints return expected JSON structures</verify>
  <done>Stage activity and pipeline breakdown endpoints return chart-ready data</done>
</task>

<task type="auto">
  <name>Task 3: Add next steps queue and admin analytics endpoints</name>
  <files>apps/journals/views.py, apps/journals/urls.py</files>
  <action>
Add final two analytics actions and register the ViewSet:

1. next_steps_queue action (@action url_path='next-steps-queue'):
   - Query NextStep with filter(journal_contact__journal__owner=request.user, completed=False)
   - Use select_related('journal_contact__contact', 'journal_contact__journal') to prevent N+1
   - Order by due_date (nulls last), then created_at
   - Limit to 20 items
   - Return list with contact_name, journal_name, title, due_date

2. admin_summary action (@action url_path='admin-summary'):
   - Add permission check: if not request.user.is_staff: return 403
   - Aggregate across ALL journals (no owner filter)
   - Return: total_journals, total_decisions, journals_by_user (annotate by owner__username)

3. Register ViewSet in urls.py:
   - Add: router.register(r'analytics', JournalAnalyticsViewSet, basename='journal-analytics')

Next steps queue implementation:
```python
@action(detail=False, methods=['get'], url_path='next-steps-queue')
def next_steps_queue(self, request):
    """Upcoming next steps across all contacts (list data)."""
    from django.db.models import F

    steps = NextStep.objects.filter(
        journal_contact__journal__owner=request.user,
        completed=False
    ).select_related(
        'journal_contact__contact',
        'journal_contact__journal'
    ).order_by(
        F('due_date').asc(nulls_last=True),
        'created_at'
    )[:20]

    return Response([
        {
            'id': str(step.id),
            'title': step.title,
            'due_date': step.due_date.isoformat() if step.due_date else None,
            'contact_name': step.journal_contact.contact.full_name,
            'journal_name': step.journal_contact.journal.name,
            'journal_contact_id': str(step.journal_contact.id),
        }
        for step in steps
    ])
```
  </action>
  <verify>All 5 analytics endpoints accessible: decision-trends, stage-activity, pipeline-breakdown, next-steps-queue, admin-summary (403 for non-staff)</verify>
  <done>All analytics endpoints created and registered, N+1 prevented with select_related</done>
</task>

</tasks>

<verification>
- [ ] GET /api/v1/journals/analytics/decision-trends/ returns monthly counts
- [ ] GET /api/v1/journals/analytics/stage-activity/ returns stage counts by month
- [ ] GET /api/v1/journals/analytics/pipeline-breakdown/ returns contact counts by stage
- [ ] GET /api/v1/journals/analytics/next-steps-queue/ returns upcoming actions list
- [ ] GET /api/v1/journals/analytics/admin-summary/ returns aggregation (staff only)
- [ ] No N+1 queries (verify with django-debug-toolbar or print statements)
</verification>

<success_criteria>
All 5 analytics endpoints return correctly structured JSON data for chart components. Admin endpoint restricted to staff users. Queries use aggregation (not N+1 loops).
</success_criteria>

<output>
After completion, create `.planning/phases/06-reporting-integration/06-01-SUMMARY.md`
</output>
