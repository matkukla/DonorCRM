---
phase: 06-reporting-integration
plan: 03
type: execute
wave: 1
depends_on: []
files_modified:
  - apps/contacts/views.py
  - apps/contacts/serializers.py
  - apps/contacts/urls.py
autonomous: true

must_haves:
  truths:
    - "GET /api/v1/contacts/{id}/journals/ returns list of journal memberships"
    - "Response includes journal name, current stage, and decision summary for each membership"
    - "Query uses select_related/prefetch_related to prevent N+1"
  artifacts:
    - path: "apps/contacts/views.py"
      provides: "journals action on ContactViewSet"
      contains: "@action.*journals"
    - path: "apps/contacts/serializers.py"
      provides: "ContactJournalMembershipSerializer"
      contains: "class ContactJournalMembershipSerializer"
  key_links:
    - from: "apps/contacts/views.py"
      to: "JournalContact"
      via: "filter and eager loading"
      pattern: "JournalContact.objects.filter.*select_related"
---

<objective>
Create contact journals API endpoint for Contact Detail Journals tab.

Purpose: Enables Contact Detail page to show all journals a contact belongs to with their stage and decision (JRN-16).
Output: API endpoint returning contact's journal memberships with optimized queries.
</objective>

<execution_context>
@/home/matkukla/.claude/get-shit-done/workflows/execute-plan.md
@/home/matkukla/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/phases/06-reporting-integration/06-RESEARCH.md

@apps/contacts/views.py
@apps/contacts/serializers.py
@apps/journals/models.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create ContactJournalMembershipSerializer</name>
  <files>apps/contacts/serializers.py</files>
  <action>
Create serializer for contact's journal memberships:

1. Add imports at top:
```python
from apps.journals.models import JournalContact, Decision, JournalStageEvent, PipelineStage
```

2. Create new serializer class:
```python
class ContactJournalMembershipSerializer(serializers.ModelSerializer):
    """Serializer for contact's journal memberships (for Journals tab)."""

    journal_id = serializers.UUIDField(source='journal.id', read_only=True)
    journal_name = serializers.CharField(source='journal.name', read_only=True)
    goal_amount = serializers.DecimalField(
        source='journal.goal_amount',
        max_digits=10,
        decimal_places=2,
        read_only=True
    )
    deadline = serializers.DateField(source='journal.deadline', read_only=True)

    # Current stage - computed from most recent event
    current_stage = serializers.SerializerMethodField()

    # Decision summary
    decision = serializers.SerializerMethodField()

    class Meta:
        model = JournalContact
        fields = [
            'id',
            'journal_id',
            'journal_name',
            'goal_amount',
            'deadline',
            'current_stage',
            'decision',
            'created_at',
        ]
        read_only_fields = fields

    def get_current_stage(self, obj):
        """Get most recent stage from prefetched events."""
        # Events are prefetched and ordered by -created_at
        events = getattr(obj, 'prefetched_events', None)
        if events:
            return events[0].stage if events else PipelineStage.CONTACT
        # Fallback if not prefetched
        latest = obj.stage_events.order_by('-created_at').first()
        return latest.stage if latest else PipelineStage.CONTACT

    def get_decision(self, obj):
        """Get decision summary from prefetched decision."""
        decisions = getattr(obj, 'prefetched_decisions', None)
        if decisions:
            decision = decisions[0] if decisions else None
        else:
            decision = obj.decisions.first()

        if not decision:
            return None

        return {
            'id': str(decision.id),
            'amount': str(decision.amount),
            'cadence': decision.cadence,
            'status': decision.status,
        }
```

This serializer expects prefetched relationships for optimal performance.
  </action>
  <verify>from apps.contacts.serializers import ContactJournalMembershipSerializer succeeds in Django shell</verify>
  <done>ContactJournalMembershipSerializer created with journal, stage, and decision fields</done>
</task>

<task type="auto">
  <name>Task 2: Add journals action to ContactViewSet</name>
  <files>apps/contacts/views.py</files>
  <action>
Add journals endpoint to ContactViewSet:

1. Add imports:
```python
from apps.journals.models import JournalContact
from django.db.models import Prefetch
from .serializers import ContactJournalMembershipSerializer
```

2. Add action method to ContactViewSet:
```python
@action(detail=True, methods=['get'], url_path='journals')
def journals(self, request, pk=None):
    """List all journals this contact belongs to with stage and decision."""
    contact = self.get_object()  # Handles permission check

    # Optimized query with prefetching per RESEARCH.md
    from apps.journals.models import JournalStageEvent, Decision

    memberships = JournalContact.objects.filter(
        contact=contact
    ).select_related(
        'journal'  # ForeignKey - single JOIN
    ).prefetch_related(
        Prefetch(
            'stage_events',
            queryset=JournalStageEvent.objects.order_by('-created_at'),
            to_attr='prefetched_events'
        ),
        Prefetch(
            'decisions',
            queryset=Decision.objects.all(),
            to_attr='prefetched_decisions'
        )
    ).order_by('-created_at')

    serializer = ContactJournalMembershipSerializer(memberships, many=True)
    return Response(serializer.data)
```

Key optimization per RESEARCH.md:
- select_related for Journal (ForeignKey = SQL JOIN)
- prefetch_related for stage_events and decisions (reverse FK = separate queries)
- Prefetch objects with to_attr for serializer access
- Total queries: 3 (memberships + events + decisions) regardless of N
  </action>
  <verify>curl /api/v1/contacts/{contact_id}/journals/ returns list of journal memberships with stage and decision</verify>
  <done>ContactViewSet has journals action with N+1 prevention</done>
</task>

<task type="auto">
  <name>Task 3: Verify endpoint with test request</name>
  <files>apps/contacts/urls.py</files>
  <action>
Verify the endpoint is properly routed (DRF actions auto-register with ViewSet routers):

1. Check that contacts app uses DefaultRouter (it should already)
2. If needed, ensure ContactViewSet is registered in urls.py

The @action decorator with detail=True automatically creates:
- GET /api/v1/contacts/{pk}/journals/

Test the endpoint:
1. Start dev server: python manage.py runserver
2. Get a contact ID from existing data
3. curl with auth:
   curl -H "Authorization: Token {token}" http://localhost:8000/api/v1/contacts/{id}/journals/
4. Verify response structure:
   ```json
   [
     {
       "id": "uuid",
       "journal_id": "uuid",
       "journal_name": "Q1 Campaign",
       "goal_amount": "5000.00",
       "deadline": "2025-03-31",
       "current_stage": "meet",
       "decision": {
         "id": "uuid",
         "amount": "100.00",
         "cadence": "monthly",
         "status": "active"
       },
       "created_at": "2025-01-15T..."
     }
   ]
   ```

If router isn't auto-registering the action, no URL changes needed - DRF handles it.
  </action>
  <verify>GET /api/v1/contacts/{id}/journals/ returns 200 with expected JSON structure</verify>
  <done>Contact journals endpoint accessible and returns correct data structure</done>
</task>

</tasks>

<verification>
- [ ] ContactJournalMembershipSerializer importable
- [ ] ContactViewSet.journals action exists
- [ ] GET /api/v1/contacts/{id}/journals/ returns 200
- [ ] Response includes journal_name, current_stage, decision fields
- [ ] No N+1 queries (should see 3 queries max regardless of membership count)
</verification>

<success_criteria>
Contact journals API endpoint returns list of journal memberships with journal details, current stage, and decision summary. Queries optimized with select_related/prefetch_related.
</success_criteria>

<output>
After completion, create `.planning/phases/06-reporting-integration/06-03-SUMMARY.md`
</output>
