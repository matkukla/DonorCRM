---
phase: 06-reporting-integration
plan: 04
type: execute
wave: 2
depends_on: ["06-01", "06-02"]
files_modified:
  - frontend/src/api/journals.ts
  - frontend/src/hooks/useJournals.ts
  - frontend/src/pages/journals/components/ReportCharts.tsx
  - frontend/src/pages/journals/components/index.ts
  - frontend/src/types/journals.ts
autonomous: true

must_haves:
  truths:
    - "User can view decision trends bar chart in Report tab"
    - "User can view stage activity area chart"
    - "User can view pipeline breakdown pie chart"
    - "User can view next steps queue list"
    - "Charts display data from analytics API endpoints"
  artifacts:
    - path: "frontend/src/pages/journals/components/ReportCharts.tsx"
      provides: "DecisionTrendsChart, StageActivityChart, PipelineBreakdownChart, NextStepsQueue"
      min_lines: 150
    - path: "frontend/src/hooks/useJournals.ts"
      provides: "Analytics query hooks"
      contains: "useDecisionTrends"
  key_links:
    - from: "frontend/src/pages/journals/components/ReportCharts.tsx"
      to: "/api/v1/journals/analytics/*"
      via: "TanStack Query hooks"
      pattern: "useDecisionTrends|useStageActivity|usePipelineBreakdown"
---

<objective>
Build Report tab UI with chart components and analytics hooks.

Purpose: Implements JRN-15 Report Tab Analytics with decision trends, stage activity, pipeline breakdown, and next steps queue.
Output: Four chart/list components with TanStack Query data fetching.
</objective>

<execution_context>
@/home/matkukla/.claude/get-shit-done/workflows/execute-plan.md
@/home/matkukla/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/phases/06-reporting-integration/06-RESEARCH.md

@frontend/src/api/journals.ts
@frontend/src/hooks/useJournals.ts
@frontend/src/types/journals.ts
@frontend/src/components/ui/chart.tsx
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add analytics types and API functions</name>
  <files>frontend/src/types/journals.ts, frontend/src/api/journals.ts</files>
  <action>
Add TypeScript types and API functions for analytics endpoints:

1. In types/journals.ts, add:
```typescript
/** Analytics data types */
export interface DecisionTrendItem {
  month: string  // 'YYYY-MM'
  count: number
}

export interface StageActivityItem {
  date: string  // 'YYYY-MM'
  contact: number
  meet: number
  close: number
  decision: number
  thank: number
  next_steps: number
}

export interface PipelineBreakdownItem {
  stage: PipelineStage
  count: number
}

export interface NextStepsQueueItem {
  id: string
  title: string
  due_date: string | null
  contact_name: string
  journal_name: string
  journal_contact_id: string
}
```

2. In api/journals.ts, add API functions:
```typescript
/** Get decision trends for charts */
export async function getDecisionTrends(): Promise<DecisionTrendItem[]> {
  const response = await apiClient.get<DecisionTrendItem[]>(
    '/journals/analytics/decision-trends/'
  )
  return response.data
}

/** Get stage activity for area chart */
export async function getStageActivity(): Promise<StageActivityItem[]> {
  const response = await apiClient.get<StageActivityItem[]>(
    '/journals/analytics/stage-activity/'
  )
  return response.data
}

/** Get pipeline breakdown for pie chart */
export async function getPipelineBreakdown(): Promise<PipelineBreakdownItem[]> {
  const response = await apiClient.get<PipelineBreakdownItem[]>(
    '/journals/analytics/pipeline-breakdown/'
  )
  return response.data
}

/** Get next steps queue */
export async function getNextStepsQueue(): Promise<NextStepsQueueItem[]> {
  const response = await apiClient.get<NextStepsQueueItem[]>(
    '/journals/analytics/next-steps-queue/'
  )
  return response.data
}
```

Import new types in api/journals.ts.
  </action>
  <verify>TypeScript compiles without errors; types importable from @/types/journals</verify>
  <done>Analytics types and API functions created</done>
</task>

<task type="auto">
  <name>Task 2: Add analytics React Query hooks</name>
  <files>frontend/src/hooks/useJournals.ts</files>
  <action>
Add TanStack Query hooks for analytics data:

```typescript
import {
  getDecisionTrends,
  getStageActivity,
  getPipelineBreakdown,
  getNextStepsQueue,
} from "@/api/journals"

/** Hook for decision trends chart data */
export function useDecisionTrends() {
  return useQuery({
    queryKey: ['journals', 'analytics', 'decision-trends'],
    queryFn: getDecisionTrends,
    staleTime: 5 * 60 * 1000, // 5 minutes - analytics can be slightly stale
  })
}

/** Hook for stage activity chart data */
export function useStageActivity() {
  return useQuery({
    queryKey: ['journals', 'analytics', 'stage-activity'],
    queryFn: getStageActivity,
    staleTime: 5 * 60 * 1000,
  })
}

/** Hook for pipeline breakdown chart data */
export function usePipelineBreakdown() {
  return useQuery({
    queryKey: ['journals', 'analytics', 'pipeline-breakdown'],
    queryFn: getPipelineBreakdown,
    staleTime: 5 * 60 * 1000,
  })
}

/** Hook for next steps queue list */
export function useNextStepsQueue() {
  return useQuery({
    queryKey: ['journals', 'analytics', 'next-steps-queue'],
    queryFn: getNextStepsQueue,
    staleTime: 2 * 60 * 1000, // 2 minutes - more time-sensitive
  })
}
```

Per RESEARCH.md:
- Query keys follow ['journals', 'analytics', <metric>] pattern
- staleTime of 5 minutes for analytics (data doesn't change every second)
- This allows cache invalidation with queryClient.invalidateQueries({ queryKey: ['journals', 'analytics'] })
  </action>
  <verify>Hooks exportable and callable without errors</verify>
  <done>Analytics query hooks created with appropriate caching</done>
</task>

<task type="auto">
  <name>Task 3: Create ReportCharts component with all charts</name>
  <files>frontend/src/pages/journals/components/ReportCharts.tsx, frontend/src/pages/journals/components/index.ts</files>
  <action>
Create ReportCharts.tsx with all four chart/list components:

```typescript
import { useMemo } from "react"
import { BarChart, Bar, AreaChart, Area, PieChart, Pie, Cell, XAxis, YAxis, CartesianGrid, ResponsiveContainer } from "recharts"
import { ChartContainer, ChartConfig, ChartTooltip, ChartTooltipContent } from "@/components/ui/chart"
import { Card, CardContent, CardDescription, CardHeader, CardTitle } from "@/components/ui/card"
import { Badge } from "@/components/ui/badge"
import { useDecisionTrends, useStageActivity, usePipelineBreakdown, useNextStepsQueue } from "@/hooks/useJournals"
import { STAGE_LABELS } from "@/types/journals"
import { formatDistanceToNow } from "date-fns"

const decisionTrendsConfig = {
  count: { label: "Decisions", color: "hsl(var(--chart-1))" },
} satisfies ChartConfig

const stageActivityConfig = {
  contact: { label: "Contact", color: "hsl(var(--chart-1))" },
  meet: { label: "Meet", color: "hsl(var(--chart-2))" },
  close: { label: "Close", color: "hsl(var(--chart-3))" },
  decision: { label: "Decision", color: "hsl(var(--chart-4))" },
  thank: { label: "Thank", color: "hsl(var(--chart-5))" },
  next_steps: { label: "Next Steps", color: "hsl(var(--chart-6))" },
} satisfies ChartConfig

const STAGE_COLORS = [
  "hsl(var(--chart-1))",
  "hsl(var(--chart-2))",
  "hsl(var(--chart-3))",
  "hsl(var(--chart-4))",
  "hsl(var(--chart-5))",
  "hsl(var(--chart-6))",
]

export function DecisionTrendsChart() {
  const { data, isLoading } = useDecisionTrends()

  if (isLoading) return <ChartSkeleton title="Decision Trends" />
  if (!data?.length) return <EmptyChart title="Decision Trends" message="No decisions recorded yet" />

  return (
    <Card>
      <CardHeader>
        <CardTitle>Decision Trends</CardTitle>
        <CardDescription>Decisions made over time</CardDescription>
      </CardHeader>
      <CardContent>
        <ChartContainer config={decisionTrendsConfig} className="min-h-[300px] w-full">
          <BarChart data={data}>
            <CartesianGrid vertical={false} />
            <XAxis dataKey="month" tickLine={false} tickMargin={10} axisLine={false} />
            <YAxis />
            <ChartTooltip content={<ChartTooltipContent />} />
            <Bar dataKey="count" fill="var(--color-count)" radius={4} />
          </BarChart>
        </ChartContainer>
      </CardContent>
    </Card>
  )
}

export function StageActivityChart() {
  const { data, isLoading } = useStageActivity()

  if (isLoading) return <ChartSkeleton title="Stage Activity" />
  if (!data?.length) return <EmptyChart title="Stage Activity" message="No stage events recorded yet" />

  return (
    <Card>
      <CardHeader>
        <CardTitle>Stage Activity</CardTitle>
        <CardDescription>Events by stage over time</CardDescription>
      </CardHeader>
      <CardContent>
        <ChartContainer config={stageActivityConfig} className="min-h-[300px] w-full">
          <AreaChart data={data}>
            <CartesianGrid vertical={false} />
            <XAxis dataKey="date" tickLine={false} tickMargin={10} axisLine={false} />
            <YAxis />
            <ChartTooltip content={<ChartTooltipContent />} />
            <Area dataKey="contact" fill="var(--color-contact)" stroke="var(--color-contact)" stackId="1" />
            <Area dataKey="meet" fill="var(--color-meet)" stroke="var(--color-meet)" stackId="1" />
            <Area dataKey="close" fill="var(--color-close)" stroke="var(--color-close)" stackId="1" />
            <Area dataKey="decision" fill="var(--color-decision)" stroke="var(--color-decision)" stackId="1" />
            <Area dataKey="thank" fill="var(--color-thank)" stroke="var(--color-thank)" stackId="1" />
            <Area dataKey="next_steps" fill="var(--color-next_steps)" stroke="var(--color-next_steps)" stackId="1" />
          </AreaChart>
        </ChartContainer>
      </CardContent>
    </Card>
  )
}

export function PipelineBreakdownChart() {
  const { data, isLoading } = usePipelineBreakdown()

  const chartData = useMemo(() => {
    if (!data) return []
    return data.map((item, index) => ({
      ...item,
      fill: STAGE_COLORS[index % STAGE_COLORS.length],
      name: STAGE_LABELS[item.stage] || item.stage,
    }))
  }, [data])

  if (isLoading) return <ChartSkeleton title="Pipeline Breakdown" />
  if (!chartData.length) return <EmptyChart title="Pipeline Breakdown" message="No contacts in pipeline yet" />

  return (
    <Card>
      <CardHeader>
        <CardTitle>Pipeline Breakdown</CardTitle>
        <CardDescription>Contacts by current stage</CardDescription>
      </CardHeader>
      <CardContent>
        <ChartContainer config={stageActivityConfig} className="min-h-[300px] w-full">
          <PieChart>
            <ChartTooltip content={<ChartTooltipContent />} />
            <Pie
              data={chartData}
              dataKey="count"
              nameKey="name"
              cx="50%"
              cy="50%"
              outerRadius={100}
              label={({ name, count }) => `${name}: ${count}`}
            >
              {chartData.map((entry, index) => (
                <Cell key={`cell-${index}`} fill={entry.fill} />
              ))}
            </Pie>
          </PieChart>
        </ChartContainer>
      </CardContent>
    </Card>
  )
}

export function NextStepsQueue() {
  const { data, isLoading } = useNextStepsQueue()

  if (isLoading) {
    return (
      <Card>
        <CardHeader>
          <CardTitle>Next Steps Queue</CardTitle>
        </CardHeader>
        <CardContent>
          <div className="space-y-2">
            {[1, 2, 3].map((i) => (
              <div key={i} className="h-16 bg-muted rounded animate-pulse" />
            ))}
          </div>
        </CardContent>
      </Card>
    )
  }

  if (!data?.length) {
    return (
      <Card>
        <CardHeader>
          <CardTitle>Next Steps Queue</CardTitle>
          <CardDescription>Upcoming actions across all contacts</CardDescription>
        </CardHeader>
        <CardContent>
          <p className="text-muted-foreground text-center py-8">No pending next steps</p>
        </CardContent>
      </Card>
    )
  }

  return (
    <Card>
      <CardHeader>
        <CardTitle>Next Steps Queue</CardTitle>
        <CardDescription>Upcoming actions across all contacts</CardDescription>
      </CardHeader>
      <CardContent>
        <div className="space-y-3">
          {data.map((step) => (
            <div key={step.id} className="flex items-start justify-between py-2 border-b last:border-0">
              <div>
                <p className="font-medium">{step.title}</p>
                <p className="text-sm text-muted-foreground">
                  {step.contact_name} &middot; {step.journal_name}
                </p>
              </div>
              {step.due_date && (
                <Badge variant={new Date(step.due_date) < new Date() ? "destructive" : "secondary"}>
                  {formatDistanceToNow(new Date(step.due_date), { addSuffix: true })}
                </Badge>
              )}
            </div>
          ))}
        </div>
      </CardContent>
    </Card>
  )
}

function ChartSkeleton({ title }: { title: string }) {
  return (
    <Card>
      <CardHeader>
        <CardTitle>{title}</CardTitle>
      </CardHeader>
      <CardContent>
        <div className="min-h-[300px] bg-muted rounded animate-pulse" />
      </CardContent>
    </Card>
  )
}

function EmptyChart({ title, message }: { title: string; message: string }) {
  return (
    <Card>
      <CardHeader>
        <CardTitle>{title}</CardTitle>
      </CardHeader>
      <CardContent>
        <div className="min-h-[300px] flex items-center justify-center">
          <p className="text-muted-foreground">{message}</p>
        </div>
      </CardContent>
    </Card>
  )
}
```

Add exports to index.ts:
```typescript
export { DecisionTrendsChart, StageActivityChart, PipelineBreakdownChart, NextStepsQueue } from './ReportCharts'
```
  </action>
  <verify>pnpm build passes; components importable from @/pages/journals/components</verify>
  <done>All four Report tab components created with proper Chart integration</done>
</task>

</tasks>

<verification>
- [ ] Analytics types exported from @/types/journals
- [ ] API functions exported from @/api/journals
- [ ] Query hooks exported from @/hooks/useJournals
- [ ] ReportCharts.tsx compiles without TypeScript errors
- [ ] pnpm build succeeds
- [ ] Components handle loading and empty states
</verification>

<success_criteria>
Report tab components ready for integration: DecisionTrendsChart (bar), StageActivityChart (area), PipelineBreakdownChart (pie), and NextStepsQueue (list). All use TanStack Query hooks with appropriate caching.
</success_criteria>

<output>
After completion, create `.planning/phases/06-reporting-integration/06-04-SUMMARY.md`
</output>
